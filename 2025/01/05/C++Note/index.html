<!DOCTYPE html>
<html lang="zh">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>C++ Note</title>
<meta name="keywords" content="C++ Note, Hello!👋 The_INK&#39;s here">
<meta name="description" content="CPP LEARNING1. new
使用new来开辟内存空间 delete来删除已开辟的空间
new返回的是该数据类型的指针
使用delete释放数组时需要用 delete[]

2.引用
引用必须要初始化
初始化后引用就不能改了
不要返">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="C++ Note">
<meta property="og:description" content="CPP LEARNING1. new
使用new来开辟内存空间 delete来删除已开辟的空间
new返回的是该数据类型的指针
使用delete释放数组时需要用 delete[]

2.引用
引用必须要初始化
初始化后引用就不能改了
不要返">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://aetherance.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://aetherance.github.io">
        <h1 class="site-title">Hello!👋 The_INK&#39;s here</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">C++ Note</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2025-01-05</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/C/">
              C++
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="CPP-LEARNING"><a href="#CPP-LEARNING" class="headerlink" title="CPP LEARNING"></a>CPP LEARNING</h1><h2 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h2><ol>
<li>使用new来开辟内存空间 delete来删除已开辟的空间</li>
<li>new返回的是该数据类型的指针</li>
<li>使用delete释放数组时需要用 delete[]</li>
</ol>
<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><ol>
<li>引用必须要初始化</li>
<li>初始化后引用就不能改了</li>
<li>不要返回局部变量的引用</li>
<li>返回值是引用的函数可以作左值</li>
<li>引用的本质在C++内部的实现就是一个指针常量</li>
<li>可以用const修饰防止形参修改实参</li>
</ol>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="1-函数的默认参数"><a href="#1-函数的默认参数" class="headerlink" title="1. 函数的默认参数"></a>1. 函数的默认参数</h3><ol>
<li>C++的函数可以有默认参数，但是从第一个默认参数开始，后面的参数都必须有默认值</li>
<li>函数的声明和实现只能有一个有默认参数</li>
</ol>
<h3 id="2-函数的重载"><a href="#2-函数的重载" class="headerlink" title="2.函数的重载"></a>2.函数的重载</h3><ol>
<li>C++的函数可以同名，提高函数的复用性。</li>
<li>函数的重载必须在同一个作用域下，且名称相同。</li>
<li>函数的重载要求满足函数的参数或者类型不同，或者个数不同，或者顺序不同。 <strong>函数的返回值不能做函数重载的条件</strong></li>
<li>引用可以做函数重载的条件 (const修饰与无const修饰) 传入常量区数据，调用const引用，传入其他数据，调用非const引用。<br>5.当重载函数有默认参数时，默认参数可能会无法重载</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;func2()的调用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;func2()的调用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func2(int a,int b = 10)</code>具有一个默认参数，这使得func2(10)具有<code>二义性</code></p>
<hr>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="C-面向对象三大特性-emsp-封装、继承、多态"><a href="#C-面向对象三大特性-emsp-封装、继承、多态" class="headerlink" title="C++ 面向对象三大特性&emsp;封装、继承、多态"></a>C++ 面向对象三大特性&emsp;封装、继承、多态</h2><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h2><h3 id="将属性和行为写在一起，并加入一些权限控制。-————-类"><a href="#将属性和行为写在一起，并加入一些权限控制。-————-类" class="headerlink" title="将属性和行为写在一起，并加入一些权限控制。 ———— 类"></a>将属性和行为写在一起，并加入一些权限控制。 ———— 类</h3><p>与<code>struct</code>不同的是 类——<code>class</code>的权限是默认私有的。<br>通过一个类来创建一个对象的过程称为 “实例化” 。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ol>
<li>公共 成员在类内可以访问 类外也可以访问</li>
<li>保护 成员在类内可以访问 类外不可以访问 父类的保护权限，子可以访问</li>
<li>私有 成员在类内可以访问 类外不可以访问 父类的私有权限，子也不可以访问 (继承)</li>
</ol>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><h4 id="使用构造函数来初始化，析构函数来清理。-构造函数和析构函数由编译器自动调用-但如果不自己实现，调用的是空实现。"><a href="#使用构造函数来初始化，析构函数来清理。-构造函数和析构函数由编译器自动调用-但如果不自己实现，调用的是空实现。" class="headerlink" title="使用构造函数来初始化，析构函数来清理。 构造函数和析构函数由编译器自动调用 但如果不自己实现，调用的是空实现。"></a>使用<code>构造函数</code>来初始化，<code>析构函数</code>来清理。 构造函数和析构函数由编译器自动调用 但如果不自己实现，调用的是空实现。</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>不需要写返回值类型，函数名称与类相同，可以有参数，可以发生重载。 <br><br>在创建对象时，程序会自动调用构造函数，不需要手动调用,并且只会调用一次</p>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>没有返回值，没有参数，函数名前要加上<code>~</code><br><br>由于不可以有参数，所以不能发生重载。<br><br>和构造函数一样，析构函数会在对象销毁前自动调用析构函数。<br><br><strong>构造和析构函数都是必须要有的</strong> 如果自己不提供，程序会提供空实现</p>
<h3 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h3><p>按参数：有参构造和无参构造<br>按类型：普通构造和拷贝构造</p>
<h3 id="构造函数的调用方式"><a href="#构造函数的调用方式" class="headerlink" title="构造函数的调用方式"></a>构造函数的调用方式</h3><ol>
<li>括号法&emsp;&emsp;&emsp;<code>person p(10);</code></li>
<li>显示法&emsp;&emsp;&emsp;<code>person p = person(10);</code></li>
<li>隐式转换法&emsp;<code>person p = &#123;10,&quot;name&quot;&#125;;</code></li>
</ol>
<p><code>person(10)</code>创建的是一个匿名对象,匿名对象在当前行结束后就会被释放。显示法相当于给匿名对象找到一个名字。<br><br><strong>不要利用拷贝构造函数来初始化一个匿名的对象。</strong></p>
<h3 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h3><p>C++中拷贝构造函数的调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完的对象来初始化一个新对象<code>person p(p0);</code></li>
<li>以值传递的方式给函数参数传参 <code>doWorK(p);</code> 值传递的本质会拷贝一个临时副本 这个过程会调用拷贝构造函数</li>
<li>以值方式返回局部对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person p1;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内的p1在函数运行完就会被是放掉,return 的p1是创建的新变量。</p>
<h3 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h3><p>C++会为一个类提供至少三个默认函数</p>
<ol>
<li>默认构造函数(空实现)</li>
<li>默认析构函数(空实现)</li>
<li>默认拷贝构造函数 &#x3D;&gt; 有默认内容(值拷贝)</li>
</ol>
<p><strong>如果你写了一个有参构造函数,C++不会提供默认无参构造，但会提供拷贝构造函数</strong><br><em><strong>如果你写了一个拷贝构造函数，C++就不会再提供默认的其他构造函数了</strong></em></p>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>深拷贝 重新申请空间<br><br>浅拷贝 直接赋值</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>传统操作:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a_,<span class="type">int</span> b_,<span class="type">int</span> c_)</span><br><span class="line">&#123;</span><br><span class="line">    a = a_;</span><br><span class="line">    b = b_;</span><br><span class="line">    c = c_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>():<span class="built_in">a</span>(<span class="number">10</span>),<span class="built_in">b</span>(<span class="number">20</span>),<span class="built_in">c</span>(<span class="number">30</span>)&#123;&#125;  <span class="comment">//行参列表</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a_,<span class="type">int</span> b_,<span class="type">int</span> c_):<span class="built_in">a</span>(a_),<span class="built_in">b</span>(b_),<span class="built_in">c</span>(c_)&#123;&#125;  <span class="comment">//更灵活的写法</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br></pre></td></tr></table></figure>

<h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当A作为B的成员时,创建一个类B的对象,会先创建一个类A的对象 &emsp; <strong>[先有手机后有人]</strong> </p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段就分配内存 (还没有运行可执行文件前已经分好了)</li>
<li>类内声明，类外初始化 (必需操作) <strong>(static修饰的成员变量在类外初始化时分配内存)</strong> <strong>(静态成员并不具体作用在某个对象上)</strong></li>
<li>静态成员不能在类内初始化</li>
<li>C++中声明和定义是有区别的，在类内进行的是成员变量的声明，而不是定义。所以在类外初始化静态成员变量时仍然要加上数据类型。</li>
<li>由于静态成员变量不属于某个类，所以他有两种访问方式</li>
<li>1.通过对象访问</li>
<li>2.通过类名访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person::static_member_</span><br></pre></td></tr></table></figure>

<ul>
<li>静态成员变量也是有访问权限的 (类外访问不到静态成员变量的内容)</li>
</ul>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
<p>成员函数的大小并不算在类里！成员变量和成员函数在存储上是分离的</p>
<p>静态成员变量的调用有两种访问方式</p>
<ol>
<li>通过对象 </li>
<li>通过类名</li>
</ol>
<p><strong>静态成员函数只能访问静态成员变量</strong></p>
<ul>
<li>静态成员函数也是有访问权限的</li>
</ul>
<h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><p>C++中 只有非静态成员变量才属于类的对象上</p>
<h4 id="空对象占用的内存大小为-1-字节"><a href="#空对象占用的内存大小为-1-字节" class="headerlink" title="空对象占用的内存大小为 1 字节"></a>空对象占用的内存大小为 1 字节</h4><p>C++编译器会给每个空对象也分配一个字节的空间，是为了区分每个对象占用的位置<br><br><em>不是存储对象的地址，而是把对象的地址占用住，防止别的对象存在同一地址</em></p>
<p><br><strong>在C++中,空结构体的大小也是 1</strong>&lt;br$$&gt;<br><strong>在C语言中 空结构体的大小是 0</strong></p>
<p>static成员变量和对象中的成员变量是分开存储的，不算在对象的大小里 (存储在全局区)</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h3><p>非静态成员函数的实例只有一份，它通过this指针来区分是哪个对象调用的自己。<br>用途</p>
<ul>
<li>当形参和成员变量同名时，可以用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可用 return *this<br>静态成员函数不具备 <code>this</code> 指针</li>
</ul>
<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++的空指针也是可以访问成员函数的<br>但是要判断this指针是否为空 加强代码的健壮性</p>
<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><h4 id="常函数"><a href="#常函数" class="headerlink" title="常函数:"></a>常函数:</h4><ul>
<li>成员函数后加 <code>const</code> 的函数叫做常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改</li>
</ul>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象:"></a>常对象:</h4><ul>
<li>在声明对象时，在对象前面加<code>const</code> 来定义一个常对象</li>
<li>常对象只能调用常函数</li>
<li><code>mutable</code>在常对象下也适用</li>
</ul>
<p>在成员函数后加const修饰的其实是this指针，让指针指向的值也不可以修改</p>
<p><strong>常对象只能调用常函数的原理：常对象的<code>this</code>指针是常量指针，而<code>this</code>指针是作为<code>隐含参数</code>传给类内函数的，只有常函数的<code>this</code>指针是常量指针常量，可以接收常对象的<code>this</code>指针</strong> <em>(其实就是普通指针可以向const修饰的指针转换，而const修饰的指针不能向普通指针转换)</em></p>
<h3 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元 friend"></a>友元 <code>friend</code></h3><p>通过关键字<code>friend</code>可以让类外访问类内的私有属性 可以让一个函数或者类 访问另一个类中的私有成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Friend</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> Friend;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="title">Friend::func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p><strong>可以对已经存在的运算符进行重新定义，赋予另一种功能</strong></p>
<ol>
<li>加号运算符重载</li>
<li>左移运算符重载</li>
<li>递增运算符重载</li>
<li>赋值运算符重载 </li>
<li>关系运算符重载</li>
<li>函数调用运算符重载 (仿函数)<br>运算符可以以全局函数或成员函数的形式重载，拓展更多使用方法<br>cout是 ostream 类的一个对象 通过成员函数 operator<code>&lt;&lt;</code> 来输出内容<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_integer&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)  <span class="comment">//在()里写int以表明这是一个后置递增</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><em>继承可以减少重复的代码。</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>      <span class="comment">// 父类 (基类)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">byBase</span> : <span class="keyword">public</span> Base  <span class="comment">// 子类 (派生类)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;func2()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <code>byBase</code> 会继承 类 <code>Base</code> 的函数 <code>func()</code> 从而拥有两个成员函数 <code>func()</code> 和 <code>func2()</code></p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。</span><br></pre></td></tr></table></figure>

<p><strong>使用共有继承方式，最大权限为公有</strong> </p>
<p><strong>使用保护继承方式，最大权限为保护</strong></p>
<p><strong>使用私有继承方式，最大权限为私有</strong></p>
<p>以私有方式继承，子类的子类什么都访问不到</p>
<h3 id="继承的对象模型"><a href="#继承的对象模型" class="headerlink" title="继承的对象模型"></a>继承的对象模型</h3><p>不管怎样继承，父类中的非静态成员属性都会被子类继承下去。</p>
<p>每个子类都会有一份继承自父类的成员</p>
<h3 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h3><p>当创建子类对象时，先有父类对象还是子类对象?</p>
<p>先构造 父类 ， 后构造 子类 。</p>
<p>析构的顺序和构造的顺序相反。</p>
<h3 id="继承中同名成员的处理方式"><a href="#继承中同名成员的处理方式" class="headerlink" title="继承中同名成员的处理方式"></a>继承中同名成员的处理方式</h3><p>在继承中遇到同名成员变量 需要在<code>.</code>后加父类的作用域</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.Base::a = <span class="number">10</span>; <span class="comment">// 表示使用的是继承自父类的成员变量</span></span><br></pre></td></tr></table></figure>

<p>对于成员函数 同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.Base::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure>

<p>如果子类中出现了和父类中同名的成员函数，那么子类会将父类中的所有成员函数隐藏掉，<strong>包括重载的函数</strong><br>必须加作用域才可以访问。</p>
<h3 id="继承中静态成员变量的处理方式"><a href="#继承中静态成员变量的处理方式" class="headerlink" title="继承中静态成员变量的处理方式"></a>继承中静态成员变量的处理方式</h3><p>静态成员变量可以通过类名访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过子类访问父类继承的静态成员变量</span></span><br><span class="line">Son::Base::m_A;</span><br></pre></td></tr></table></figure>

<h3 id="C-多继承"><a href="#C-多继承" class="headerlink" title="C++多继承"></a>C++多继承</h3><p>C++允许一个类继承多个类</p>
<p>当父类中出现同名成员 需要加作用域区分</p>
<p><strong>在开发中不建议采用多继承写法</strong></p>
<h3 id="菱形继承-virtual"><a href="#菱形继承-virtual" class="headerlink" title="菱形继承 (virtual)"></a>菱形继承 (virtual)</h3><p>两个派生类继承同一个基类，又被同一个派生类继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">C     D</span><br><span class="line"> \   /</span><br><span class="line">   E</span><br></pre></td></tr></table></figure>
<p>E通过C，D继承A的成员时，只需要一份，却继承了两份，造成资源浪费</p>
<p>此时可以通过<code>虚继承</code>实现</p>
<p>继承时加上<code>virtual</code> 后，继承方式变为虚继承 , 数据只存一份</p>
<p>并且虚继承默认访问的是第一个基类 </p>
<p>虚继承的派生类中存的是<code>vbptr</code> <strong>『虚基类指针』</strong> 指向 <code>vbtable</code> <strong>『虚基类表』</strong> 记录了派生类成员相对基类成员的偏移量</p>
<h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><h3 id="静态多态和动态多态"><a href="#静态多态和动态多态" class="headerlink" title="静态多态和动态多态"></a>静态多态和动态多态</h3><p>静态多态：函数重载和运算符重载</p>
<p>动态多态：派生类和虚函数来实现动态多态</p>
<p>区别:</p>
<ul>
<li>静态多态的函数地址早绑定 &#x3D;&gt; 在编译阶段就确定了函数的地址</li>
<li>动态多态的函数地址晚绑定 &#x3D;&gt; 程序运行时才能确定函数地址</li>
</ul>
<p>C++允许父类的引用指向一个子类对象 不需要进行类型转换</p>
<p>通过在基类的函数前加入关键字<code>virtual</code>，可以实现地址晚绑定，使一个函数表现出不同的效果</p>
<p>动态多态的条件：</p>
<ol>
<li>有基础关系</li>
<li>子类要重写父类的虚函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写:函数的返回值，形参和函数名都要相同</span><br><span class="line">重载:根据形参的不同区分两个函数</span><br></pre></td></tr></table></figure>

<p>动态多态的使用: 要用父类的指针或引用指向子类的对象 调用虚函数</p>
<h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><p>有虚函数的基类中会存一个被称为<code>vfptr</code>的指针 即<code>虚函数指针</code> (aka虚函数表指针)<br>它会指向一个虚函数表<code>vftable</code> 该表内部会记录一个虚函数的地址 </p>
<p>子类会继承父类的<code>vfptr</code>指向自己的虚函数表 父类和子类不会共享一个虚函数表</p>
<p>类的对象的隐藏成员保存的类的虚函数指针(vfptr)，指向类的虚函数表 虚函数表是一个顺序表 表中有许多槽(slot),每个槽中存放的是一个虚函数的指针(地址) </p>
<p>如果派生类重写了基类的虚函数，派生虚函数表将基类虚函数的地址替换为派生类虚函数的地址，<br>如果派生类中没有重写虚函数，派生虚函数表将保存基类虚函数的地址。如果派生类中还定义了虚函数，那么该虚函数的地址也会被添加到虚派生类表里去。</p>
<p>为了保证虚函数表的性能，C++会保证虚函数表的指针存在于对象实例的最前面的位置。</p>
<p>当父类的指针或者引用指向子类对象时，就会发生<code>多态</code></p>
<p>在创建派生类的对象时，虚函数指针会被指向派生类虚函数表。</p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>多态中父类的虚函数大多没什么用,可以将虚函数改为纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义一个纯虚函数 </span></span><br></pre></td></tr></table></figure>
<p>只要类中有一个纯虚函数，类就会成为<code>抽象类</code> 无法实例化一个对象</p>
<p>抽象类的子类必须重写抽象类的纯虚函数，否则该子类也属于抽象类，无法实例化对象</p>
<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，父类的指针无法释放子类中的析构代码，所以子类数据无法释放，会造成内存泄漏。</p>
<p>此时需要利用<code>虚析构</code>和<code>纯虚析构</code> 虚析构和纯虚析构都需要函数的实现</p>
<p>如果类中有了纯虚析构，该类也会属于抽象类</p>
<p>只要在父类的析构函数前加上<code>virtual</code> 即可调用子类的析构函数</p>
<p>纯虚析构也能有这个效果,但是纯虚析构必须在类外实现函数体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 实现 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型和STL"><a href="#泛型和STL" class="headerlink" title="泛型和STL"></a>泛型和STL</h1><p>C++支持<code>泛型编程</code> 和 <code>STL</code></p>
<p><code>泛型编程</code>主要靠<code>模板</code>实现,可大大提高复用性。   </p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ol>
<li>模板不可以直接使用，它只是一个框架。</li>
<li>模板的通用并不是万能的。</li>
</ol>
<h3 id="模板的语法"><a href="#模板的语法" class="headerlink" title="模板的语法"></a>模板的语法</h3><ul>
<li>函数模板</li>
<li>类模板</li>
</ul>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>语法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 函数声明或定义</span></span><br></pre></td></tr></table></figure>
<p>写模板时可以先不指定返回值和形参是什么数据类型 使用的时候再确定数据类型</p>
<p>template: 声明创建模板<br>typename: 表明T是数据类型的名称 可以用class替代<br>T 是可以替换的数据类型 (自定义)</p>
<p>***36_STL</p>
<hr>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><code>STL</code> 即 <code>Standard Template Library</code> 标准模板库</p>
<p>STL 从广义上分为 <strong><code>容器(container)</code></strong> <strong><code>算法(algorithm)</code></strong> <strong><code>迭代器(iterator)</code></strong> </p>
<p>迭代器连接了容器与算法</p>
<p>STL中的所有类基本上都使用了模板类和模板函数</p>
<p>STL的六大组件 – 容器、算法、迭代器、仿函数、适配器、空间配置器</p>
<ol>
<li>容器 是各种数据结构 用来存储数据</li>
<li>算法 各种常用的算法 (sort,find,copy,for_each)</li>
<li>迭代器 迭代器 交流容器和算法</li>
<li>仿函数 函数调用运算符的重载</li>
<li>适配器 用来修饰容器或者仿函数或迭代器接口</li>
<li>空间配置器 负责空间的配置和管理</li>
</ol>
<p><strong>容器</strong>分为序列式容器和关联式容器</p>
<p>序列式容器强调值的排序，每个元素都有固定的位置</p>
<p>关联式容器各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法</strong>分为质变算法和非质变算法</p>
<p>质变算法在运行期间会更改元素的内容     (增，删，改)</p>
<p>非质变算法在运行期间不会改变元素的内容 (查找，计数)</p>
<p>算法要通过迭代器才能访问容器里的元素 每种容器都有自己专属的迭代器</p>
<p>迭代器非常类似于指针</p>
<p>迭代器的种类: 输入、输出、向前、双向、随机访问</p>
<p><code>输入迭代器</code>对数据进行只读访问</p>
<p><code>输出迭代器</code>对数据进行只写访问</p>
<p><code>前向迭代器</code>可以向前推进，并且可以进行读写操作</p>
<p>**<code>双向迭代器</code>**可以进行读写操作，并且可以向前和向后操作</p>
<p>**<code>随机访问迭代器</code>**支持读写操作，并且可以以跳跃的方式访问任意数据</p>
<h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><p>vector容器可以理解为一个数组。</p>
<h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><p>封装了C语言的字符串</p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#CPP-LEARNING"><span class="top-box-text">CPP LEARNING</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-new"><span class="top-box-text">1. new</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-%E5%BC%95%E7%94%A8"><span class="top-box-text">2.引用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-%E5%87%BD%E6%95%B0"><span class="top-box-text">3.函数</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="top-box-text">1. 函数的默认参数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="top-box-text">2.函数的重载</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="top-box-text">类和对象</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-emsp-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81"><span class="top-box-text">C++ 面向对象三大特性 封装、继承、多态</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-%E5%B0%81%E8%A3%85"><span class="top-box-text">1. 封装</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B0%86%E5%B1%9E%E6%80%A7%E5%92%8C%E8%A1%8C%E4%B8%BA%E5%86%99%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%B9%B6%E5%8A%A0%E5%85%A5%E4%B8%80%E4%BA%9B%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E3%80%82-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E7%B1%BB"><span class="top-box-text">将属性和行为写在一起，并加入一些权限控制。 ———— 类</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="top-box-text">访问权限</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="top-box-text">构造函数和析构函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="top-box-text">构造函数的分类</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="top-box-text">构造函数的调用方式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="top-box-text">拷贝构造函数的调用时机</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="top-box-text">构造函数的调用规则</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="top-box-text">深浅拷贝</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="top-box-text">初始化列表</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="top-box-text">类对象作为类成员</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="top-box-text">静态成员变量</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="top-box-text">静态成员函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="top-box-text">C++对象模型和this指针</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#this%E6%8C%87%E9%92%88"><span class="top-box-text">this指针</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="top-box-text">空指针访问成员函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="top-box-text">const修饰成员函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%8B%E5%85%83-friend"><span class="top-box-text">友元 friend</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="top-box-text">运算符重载</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="top-box-text">2. 继承</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="top-box-text">基本语法</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="top-box-text">继承方式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="top-box-text">继承的对象模型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="top-box-text">构造和析构顺序</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="top-box-text">继承中同名成员的处理方式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="top-box-text">继承中静态成员变量的处理方式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#C-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="top-box-text">C++多继承</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF-virtual"><span class="top-box-text">菱形继承 (virtual)</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-%E5%A4%9A%E6%80%81"><span class="top-box-text">3. 多态</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="top-box-text">静态多态和动态多态</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="top-box-text">多态的原理</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="top-box-text">纯虚函数和抽象类</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="top-box-text">虚析构和纯虚析构</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8CSTL"><span class="top-box-text">泛型和STL</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A8%A1%E6%9D%BF"><span class="top-box-text">模板</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="top-box-text">模板的语法</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#STL"><span class="top-box-text">STL</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="top-box-text">vector容器</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#string%E5%AE%B9%E5%99%A8"><span class="top-box-text">string容器</span></a></li></ol></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2025/01/01/2024%E5%9B%9E%E9%A1%BE/">
          <h3 class="post-title">
            下一篇：2024回顾
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/Aetherance" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

