<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello!👋 The_INK&#39;s here</title>
  
  
  <link href="http://aetherance.github.io/atom.xml" rel="self"/>
  
  <link href="http://aetherance.github.io/"/>
  <updated>2025-03-11T09:28:50.799Z</updated>
  <id>http://aetherance.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RAII</title>
    <link href="http://aetherance.github.io/2025/03/11/RAII/"/>
    <id>http://aetherance.github.io/2025/03/11/RAII/</id>
    <published>2025-03-11T09:28:50.000Z</published>
    <updated>2025-03-11T09:28:50.799Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++智能指针</title>
    <link href="http://aetherance.github.io/2025/03/11/smart-ptr/"/>
    <id>http://aetherance.github.io/2025/03/11/smart-ptr/</id>
    <published>2025-03-11T02:28:25.000Z</published>
    <updated>2025-03-11T13:11:30.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++提供了以下几种智能指针</p><ol><li><code>unique_ptr</code></li><li><code>shared_ptr</code></li><li><code>weak_ptr</code></li><li><code>auto_ptr</code></li></ol><p>其中<code>auto_ptr</code>由于过于抽象已被弃用，所以本文只讨论前三种智能指针。</p><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p><code>unique_ptr</code>遵循<code>独占所有权</code>语义。被<code>unique_ptr</code>持有的资源不能同时被其他任何<code>unique_ptr</code>持有,也不应被其他任何智能指针持有。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>unique_ptr</code>大致有以下几种初始化方式。</p><ul><li>直接使用构造函数</li><li>使用<code>make_unique</code></li><li>通过移动语义转移所有权</li><li>初始化为空</li></ul><p>对于动态开辟的数组，<code>unique_ptr</code>应当使用<code>T[]</code>模板，以便编译器调用<code>delete[]</code>作为删除器。或者，也可以自定义一个删除器。</p><p>删除器可以是函数指针，对象或lambda表达式。删除器的类型需要函数模板参数传入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span> * obj)&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] obj;</span><br><span class="line">&#125;；</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>[],<span class="keyword">decltype</span>(deleter)&gt;<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],deleter); <span class="comment">// decltype可推断出deleter的类型。</span></span><br></pre></td></tr></table></figure><h2 id="独占所有权"><a href="#独占所有权" class="headerlink" title="独占所有权"></a>独占所有权</h2><p><code>unique_ptr</code>的拷贝构造函数和赋值运算符被显式删除。因此<code>unique_ptr</code>无法被复制而产生一个新的实例。这使<code>unique_ptr</code>的所有权不会被分离到两个<code>unique_ptr</code>实例。</p><p><code>unique_ptr</code>可以通过<code>移动语义</code>来转移自身持有的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个unique_ptr的资源转移到另一个unique_ptr</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt;ptr1 = <span class="built_in">make_unique</span>&lt;string&gt;(str);</span><br><span class="line">unique_ptr&lt;string&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p><code>shared_ptr</code>的初始化与<code>unique_ptr</code>类似，但是也有所不同。</p><ul><li>与<code>unique_ptr</code>类似，<code>shared_ptr</code>可以使用<code>make_shared</code>初始化，这也是较安全的初始化方式。</li><li><code>shared_ptr</code>允许拷贝操作，这同时也会增加<code>shared_ptr</code>内部的引用计数器。</li><li>使用移动语义可以将<code>unique_ptr</code>的资源转移至<code>shared_ptr</code>。</li></ul><h2 id="共享资源机制"><a href="#共享资源机制" class="headerlink" title="共享资源机制"></a>共享资源机制</h2><p>多个<code>shared_ptr</code>可以指向同一个对象。</p><p><code>shared_ptr</code>内部维护了一个线程安全的计数器，其代表了<code>shared_ptr</code>指向的对象被不同<code>shared_ptr</code>实例引用的次数。</p><p>当该计数器归零时，<code>shared_ptr</code>指向的对象将被销毁，同时，对象的析构函数也会被调用。</p><p>虽然<code>shared_ptr</code>的引用计数是线程安全的，然而，对被<code>shared_ptr</code>管理的对象的操作却不是线程安全的。在多线程环境下操作<code>shared_ptr</code>管理的对象时，需要额外的同步机制。</p><p><code>shared_ptr</code>可以指定释放资源的方式，自定义删除方法。</p><p>每个<code>shared_ptr</code>会创建一个<code>控制块</code>，包括引用计数，弱引用计数，删除器和分配器。首次创建<code>shared_ptr</code>时，该控制块会被创建。</p><h2 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h2><p>控制块的内存和对象的内存同时开辟，并且为一次分配。这减少了内存开辟的次数，提高了效率。</p><p>内存块的引用计数是原子操作，保证线程安全。</p><p>只有在弱引用归0时，控制块的内存才会被释放。所以，对象和控制块的构造一定是同时的，但销毁不一定是同时的</p><h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p><code>shared_ptr</code>使用不当会导致<code>循环引用</code>，即对象的成员变量<code>shared_ptr</code>引用了对象。这导致在对象析构之前，对象的<code>shared_ptr</code>成员变量会一直指向<code>shared_ptr</code>实例，等待对象析构，然而，对象析构的条件是没有一个<code>shared_ptr</code>实例指向该对象。最终对象和<code>shared_ptr</code>实例会陷入一种类似死锁的”僵持”，最终内存无法释放，导致内存泄露。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个类对象间的循环引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt;ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt;ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;A&gt;ptr2 = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    shared_ptr&lt;B&gt;ptr1 = <span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    </span><br><span class="line">    ptr2-&gt;ptr = ptr1;</span><br><span class="line">    ptr1-&gt;ptr = ptr2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其中一个类内的<code>shared_ptr</code>改为<code>weak_ptr</code>可以解决这个问题。</p><h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p><code>weak_ptr</code>可以观察<code>shared_ptr</code>管理的资源，却不会增加引用计数，因此，<code>weak_ptr</code>可以解决循环引用的问题。</p><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak1</span><span class="params">(shared)</span></span>;        <span class="comment">// 从 shared_ptr 构造</span></span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak2</span><span class="params">(weak1)</span></span>;         <span class="comment">// 从另一个 weak_ptr 拷贝构造</span></span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>可以从<code>shared_ptr</code>构造，也可以从另一个<code>weak_ptr</code>拷贝。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p><code>expired()</code>: 用于检查资源是否已被释放，如果已释放，返回<code>true</code>。</p><p><code>lock()</code>: 会返回一个<code>shared_ptr</code>，只有通过这个<code>shared_ptr</code>，<code>weak_ptr</code>才可以操作观察的资源。</p><p><code>use_count()</code>: 返回强引用计数。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>利用C++提供的智能指针，我们可以刚好地管理程序内的各种资源。</p><p>例如，线程池可以用<code>unique_ptr</code>管理，以确保程序中线程池实例独一无二。</p><p>在多线程环境下，使用<code>shared_ptr</code>也可以妥善管理那些全局共享的对象，以确保该对象不会在被使用时已经是被销毁的了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++提供了以下几种智能指针&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sha</summary>
      
    
    
    
    
    <category term="C++" scheme="http://aetherance.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP</title>
    <link href="http://aetherance.github.io/2025/03/04/TCP-IP/"/>
    <id>http://aetherance.github.io/2025/03/04/TCP-IP/</id>
    <published>2025-03-04T13:08:29.000Z</published>
    <updated>2025-03-09T08:25:27.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h1><p>TCP&#x2F;IP协议将网络分为4层</p><p>从上到下依次是 应用层 传输层 网络层 数据链路层</p><p>TCP&#x2F;IP 分别为传输层和网络层的协议。</p><p><a class="simple-lightbox" href="/../res/TCP-IP.png"><img   src="/images/loading.svg" data-src="/../res/TCP-IP.png"  lazyload></a></p><p>一个应用A向应用B传输信息的大致过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">             封装为 包      封装为 帧               检查 IP 头部 若匹配，剥离 IP 头部，将段交给传输层。</span><br><span class="line">             添加 IP 头部   添加 帧头和帧尾          若不匹配且本机为路由器，则重新路由转发</span><br><span class="line">             |             |                     |</span><br><span class="line">应用A-&gt;传输层-&gt;网络层-&gt;数据链路层-&gt;网络介质-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用B(接收数据)</span><br><span class="line">       |                       |       |                |</span><br><span class="line">       添加 传输层头部           比特流   剥离帧头和帧尾      检查端口号，确定目标应用    </span><br><span class="line">       封装为 段 或 数据报。              校验帧完整性       剥离传输层头部，将原始数据交给应用层。</span><br><span class="line">高层                        低层      低层                        高层</span><br></pre></td></tr></table></figure><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP（Internet Protocol，互联网协议）是用于在计算机网络中标识和定位设备的一组规则。</span><br><span class="line">它是互联网通信的基础协议之一，主要作用是为每个连接到网络的设备分配一个唯一的地址（称为IP地址），确保数据能够准确地在设备之间传输。</span><br></pre></td></tr></table></figure><p>IP协议是一种 <strong>无连接</strong> 和 <strong>不可靠</strong> 的协议。</p><p>无连接：IP协议在发送数据之前不会建立连接。</p><p>不可靠：IP协议不保证数据按顺序到达，不保证数据不重复，也不保证数据不丢失。</p><p>IP协议会通过IP地址标识网络中的设备，在一个网络中，设备的IP地址是唯一的。</p><p>IP协议会根据网络最大传输单元(MTU)拆分数据包，并在接收端重组。</p><p>IP会将数据包封装成有固定20字节头部的数据包</p><p><a class="simple-lightbox" href="/../res/ipv4head.png"><img   src="/images/loading.svg" data-src="/../res/ipv4head.png"  lazyload></a></p><p>IP协议的两个版本</p><ol><li>IPv4</li><li>IPv6</li></ol><p>IPv4地址由32位二进制数组成，可表示约43亿地址。为方便阅读，IPv4地址可用点分十进制表示。如<code>192.168.0.1</code></p><p>IPv4目前是主流的IP表示方案，但也存在着能够表示的地址不够的问题。</p><p>IPv6解决了这一问题。其地址为128位的二进制数，可以表示约<code>3.4×10³⁸</code>地址个地址。</p><p>IPv6的头部为固定的40字节，每个设备都可以有公网地址。IPv6的地址还可以表示为十六进制冒号分隔的形式 如 <code>2001:0db8:85a3::8a2e:0370:7334</code>。</p><h2 id="IP核心机制"><a href="#IP核心机制" class="headerlink" title="IP核心机制"></a>IP核心机制</h2><h3 id="1-分片和重组机制"><a href="#1-分片和重组机制" class="headerlink" title="1. 分片和重组机制"></a>1. 分片和重组机制</h3><p>IP会将数据包分片与重组，当数据包的大小超过MTU，数据包会被拆分成多个分片，到达接收端后，数据包会被根据标志和片位移重组。</p><h3 id="2-TTL机制"><a href="#2-TTL机制" class="headerlink" title="2. TTL机制"></a>2. TTL机制</h3><p>TTL，即<code>Time to Live</code>(生存时间)。没经过一个路由器，TTL值会减1。当一个数据包的TTL值为0时，这个数据包会被路由器丢弃。</p><p>设定TTL值并在其为0时丢弃是为了防止数据包在网络中无限循环。</p><h3 id="3-路由机制"><a href="#3-路由机制" class="headerlink" title="3. 路由机制"></a>3. 路由机制</h3><p>每个路由器都有一张路由表，存储目标网络和下一跳的映射。</p><p>如果目标IP和路由器在同一个子网，数据包会被直接发给目标设备。</p><p>如果目标IP和路由器不在同一个子网，数据包会被发送到默认网关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断是否在同一子网——子网掩码</span><br><span class="line"></span><br><span class="line">IPv4地址 = 网络地址 + 主机号</span><br><span class="line">如果两个IP的网络地址相同，那么可以确定这两个IP在同一个子网</span><br><span class="line">通过子网掩码便可以确定一个IP地址的网络地址。</span><br><span class="line"></span><br><span class="line">网络地址 = IP地址 &amp; 子网掩码</span><br></pre></td></tr></table></figure><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>​<strong>连接方式</strong></td><td>面向连接（三次握手建立，四次挥手释放   ）</td><td>无连接，直接发送数据</td></tr><tr><td>​<strong>可靠性</strong></td><td>可靠传输（确认、重传、校验）</td><td>不可靠传输（无确认、无重传）</td></tr><tr><td>​<strong>流量控制</strong></td><td>通过滑动窗口动态调节发送速率</td><td>无流量控制</td></tr><tr><td>​<strong>拥塞控制</strong></td><td>有（慢启动、拥塞避免等算法）</td><td>无</td></tr><tr><td>​<strong>数据顺序</strong></td><td>保证数据按顺序到达</td><td>不保证顺序</td></tr><tr><td>​<strong>头部开销</strong></td><td>较大（20 字节固定 + 可选字段）</td><td>较小（固定 8 字节）</td></tr><tr><td>​<strong>传输方式</strong></td><td>基于字节流（无明确边界）</td><td>基于数据报（有明确边界）</td></tr><tr><td>​<strong>传输效率</strong></td><td>低（握手、重传、控制机制）</td><td>高（无额外控制）</td></tr><tr><td>​<strong>延迟</strong></td><td>较高（可靠性机制引入延迟）</td><td>较低（适合实时应用）</td></tr><tr><td>​<strong>广播&#x2F;多播支持</strong></td><td>仅支持单播</td><td>支持广播和多播</td></tr><tr><td>​<strong>典型应用场景</strong></td><td>HTTP、FTP、电子邮件、文件传输</td><td>视频流、在线游戏、DNS、VoIP、实时通信</td></tr></tbody></table><p>TCP是一种 <strong>面向连接</strong> 的 <strong>可靠</strong> 传输协议。 并且TCP协议支持流量控制和拥塞控制，可以进行全双工通信。</p><p>使用TCP协议通信前需要先建立连接，通信结束后也需要断开连接。</p><h3 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h3><ol><li>校验和</li></ol><p>每个TCP报文都带校验和字段，通过校验和可以验证数据的完整性。</p><ol start="2"><li>确认应答机制</li></ol><p>接收方在成功接收数据后，会向发送方发送一个带ACK标志位的数据包，该数据包中包含了<code>确认号</code></p><p>确认号是成功接收的这个数据包下一个数据包的序列号，表示以确认号为序列号的数据包之前的数据包都收到了。</p><ol start="3"><li>超时重传机制</li></ol><p>在一定时间后，如果还没有收到某个数据包的ACK，发送方会重传该数据包。</p><ul><li>快速重传：接收方检测到乱序包，会重新发送前一个ACK。当发送方收到三次重复ACK时，会立即重传。</li></ul><ol start="4"><li>滑动窗口</li></ol><p>使用TCP协议的发送方和接收方各维护了一个滑动窗口。 通过这两个滑动窗口TCP可以实现流量控制和拥塞控制。</p><p><a class="simple-lightbox" href="/../res/tcphead.png"><img   src="/images/loading.svg" data-src="/../res/tcphead.png"  lazyload></a></p><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>客户端向服务器发送一个带有标志位SYN的数据包，表明自己希望与服务器建立连接。 客户端的TCP状态变为SYN_SENT</li><li>服务器回复一个带有标志位SYN和ACK的数据包，表示同意建立连接。 服务器的TCP状态变为SYN_RECEIVED</li><li>客户端接收到服务器的SYN-ACK包后，回应一个ACK包，表示连接建立。 服务器和客户端的TCP状态都变为ESTABLISHED，连接建立。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三次握手</span><br><span class="line">服务器: LISTEN -&gt; SYN_R可靠传输四大机制、握手/挥手状态转换、滑动窗口原理CVD -&gt; ESTABLISHED</span><br><span class="line">客户端:     CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED</span><br></pre></td></tr></table></figure><p><a class="simple-lightbox" href="/../res/tcp-connect.png"><img   src="/images/loading.svg" data-src="/../res/tcp-connect.png"  lazyload></a></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol><li>主动方向被动方发送一个带标志位FIN的数据包，表示自己想要终止连接。 主动方进入FIN_WAIT_1状态。</li><li>被动方收到FIN包，回应一个ACK包，表示确认收到关闭请求。 被动关闭方进入CLOSE_WAIT状态。 主动方接收ACK后进入FIN_WAIT_2状态</li><li>被动方在数据发送完毕后，向主动方发送一个带FIN标识位的数据包，表示被动方也要终止连接。 被动方进入LAST_ACK状态。</li><li>主动方收到FIN包后，向被动方发送一个ACK包，并进入TIME_WAIT状态。被动方接收ACK后终止连接，主动方一段时间后终止连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                        发送FIN          接收ACK        接收FIN并发送ACK</span><br><span class="line">四次挥手                    |             |             |</span><br><span class="line">主动方:     ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</span><br><span class="line">被动方:     ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK   -&gt; CLOSED</span><br><span class="line">                         |              |           |</span><br><span class="line">                        接收FIN,回应ACK  数据发送完毕   接收ACK </span><br></pre></td></tr></table></figure><p><a class="simple-lightbox" href="/../res/tcp-disconnect.png"><img   src="/images/loading.svg" data-src="/../res/tcp-disconnect.png"  lazyload></a></p><p>利用TCP&#x2F;IP协议，我们可以实现服务器和客户端之间的通信。</p><p><a class="simple-lightbox" href="/../res/socket.png"><img   src="/images/loading.svg" data-src="/../res/socket.png"  lazyload></a></p><p>服务器：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    sockaddr_in sin;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sin,<span class="number">0</span>,<span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    sin.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(lfd,(sockaddr*)&amp;sin,<span class="built_in">sizeof</span>(sockaddr_in)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(lfd,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    sockaddr_in client_sin;</span><br><span class="line">    <span class="type">socklen_t</span> client_sin_len = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">accept</span>(lfd,(sockaddr*)&amp;client_sin,&amp;client_sin_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send</span>(sock,<span class="string">&quot;Hello World!&quot;</span>,<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockaddr_in sin;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sin,<span class="number">0</span>,<span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;localhost&quot;</span>,&amp;sin.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sock,(sockaddr*)&amp;sin,<span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">13</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recv</span>(sock,buff,<span class="number">13</span>,<span class="number">0</span>);</span><br><span class="line">    std::cout&lt;&lt;buff;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过TCP&#x2F;IP协议，服务器可以向客户端发送一条消息<code>Hello World!</code>。客户端接收<code>Hello World!</code>后将其打印在客户端的屏幕上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-IP网络模型&quot;&gt;&lt;a href=&quot;#TCP-IP网络模型&quot; class=&quot;headerlink&quot; title=&quot;TCP&amp;#x2F;IP网络模型&quot;&gt;&lt;/a&gt;TCP&amp;#x2F;IP网络模型&lt;/h1&gt;&lt;p&gt;TCP&amp;#x2F;IP协议将网络分为4层&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="网络编程" scheme="http://aetherance.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++左右值</title>
    <link href="http://aetherance.github.io/2025/02/24/C-lr-val/"/>
    <id>http://aetherance.github.io/2025/02/24/C-lr-val/</id>
    <published>2025-02-24T12:45:25.000Z</published>
    <updated>2025-03-12T01:22:34.630Z</updated>
    
    <content type="html"><![CDATA[<p>C++中所有的值都可以分为<code>左值</code>和<code>右值</code>。</p><h1 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h1><p>左值是“有身份“的值。一个左值一定是能够被取地址的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;      <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x;   <span class="comment">// ref 是左值引用，绑定到左值 x</span></span><br></pre></td></tr></table></figure><p>左值通常是程序中可持久化存在，能被频繁访问的对象。左值一定会被分配一个可操作的地址。</p><p>左值的生命周期通常较长，一般超出单个表达式的作用域。</p><h1 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h1><p>右值有两个核心特征： 可移动性 和 临时性。</p><p>C++11 之后，右值也可以分为两类。</p><ol><li>纯右值</li><li>将亡值</li></ol><h2 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h2><p>纯右值是纯粹的临时值，没有身份，不可以取地址。</p><p>通常，纯右值用来表示计算结果，非引用返回值，构造函数调用生成的临时对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread</span>(func); <span class="comment">// 这样的一个值是纯右值。</span></span><br></pre></td></tr></table></figure><p>一个纯右值如果没有一个左值来接收，那么这个纯右值将会立即死去。</p><h2 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h2><p>将亡值是一个具有身份但即将被销毁的值。同样地，一个将亡值如果没有一个左值来接收，这个将亡值也会立即死去。</p><p>将亡值通常是被<code>move</code>等标记过的值，或者右值引用返回值。</p><p>通过将亡值，C++支持了<code>移动语义</code>。</p><p>利用移动语义，我们可以将资源从一个实例<code>转移</code>到另一个实例。在某些情况下，这十分关键。</p><p>例如，智能指针<code>unique_ptr</code>具有独占所有权的机制。所以在<code>unique_ptr</code>间转移资源时，移动语义非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个unique_ptr的资源转移到另一个unique_ptr</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt;ptr1 = <span class="built_in">make_unique</span>&lt;string&gt;(str);</span><br><span class="line">unique_ptr&lt;string&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure><p>其中<code>move()</code>的作用是让左值ptr1变成一个将亡值。</p><h1 id="左值引用、右值引用与移动语义"><a href="#左值引用、右值引用与移动语义" class="headerlink" title="左值引用、右值引用与移动语义"></a>左值引用、右值引用与移动语义</h1><p>C++11后，编译器支持使用<code>&amp;&amp;</code>来表示一个右值引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;         <span class="comment">// 左值</span></span><br><span class="line"><span class="type">int</span> &amp; ref = a;      <span class="comment">// 左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; ref2 = a;    <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure><p><code>move</code>可以将一个左值转化为一个右值引用，以便触发移动构造函数，从而使用移动语义。</p><p>与<code>拷贝构造函数</code>类似，<code>移动构造函数</code>也是通过不同的参数重载的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(String&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">data_</span>(other.data_), <span class="built_in">size_</span>(other.size_) &#123; <span class="comment">// 1. 窃取资源</span></span><br><span class="line">        <span class="comment">// 2. 置空源对象，避免重复释放</span></span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>; </span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在移动构造函数中，应该将管理资源的原裸指针置空。对于STL中的容器或者std::unique_ptr，应该使用move进行资源的移动。</p><p>而对于其他内置数据类型，则不必过多关心。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++中所有的值都可以分为&lt;code&gt;左值&lt;/code&gt;和&lt;code&gt;右值&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;左值&quot;&gt;&lt;a href=&quot;#左值&quot; class=&quot;headerlink&quot; title=&quot;左值&quot;&gt;&lt;/a&gt;左值&lt;/h1&gt;&lt;p&gt;左值是“有身份“的值。一个左值一定</summary>
      
    
    
    
    
    <category term="C++" scheme="http://aetherance.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>小发现</title>
    <link href="http://aetherance.github.io/2025/02/11/C-C-buff/"/>
    <id>http://aetherance.github.io/2025/02/11/C-C-buff/</id>
    <published>2025-02-11T05:32:34.000Z</published>
    <updated>2025-03-12T03:46:04.621Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序居然会先sleep再打印。</p><p>其实是缓冲区刷新之后才会打印到屏幕上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="http://aetherance.github.io/2025/02/07/TCP-connect/"/>
    <id>http://aetherance.github.io/2025/02/07/TCP-connect/</id>
    <published>2025-02-07T08:34:17.000Z</published>
    <updated>2025-02-07T12:52:34.373Z</updated>
    
    <content type="html"><![CDATA[<p>TCP&#x2F;IP协议是一个分层联网协议。它包含IP和位于其上的其他协议层。</p><p>TCP&#x2F;IP协议具有一个重要原则——<strong>封装</strong>。其关键概念为：低层不会对高层传来的信息进行解释。</p><p>当信息从高层传向低层，会加一层本层的头信息。而信息从低层传向高层时，会有一个解包的过程。</p><p>一个应用A向应用B传输信息的大致过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">             封装为 包      封装为 帧               检查 IP 头部 若匹配，剥离 IP 头部，将段交给传输层。</span><br><span class="line">             添加 IP 头部   添加 帧头和帧尾          若不匹配且本机为路由器，则重新路由转发</span><br><span class="line">             |             |                     |</span><br><span class="line">应用A-&gt;传输层-&gt;网络层-&gt;数据链路层-&gt;网络介质-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用B(接收数据)</span><br><span class="line">       |                       |       |                |</span><br><span class="line">       添加 传输层头部           比特流   剥离帧头和帧尾      检查端口号，确定目标应用    </span><br><span class="line">       封装为 段 或 数据报。              校验帧完整性       剥离传输层头部，将原始数据交给应用层。</span><br><span class="line">高层                        低层      低层                        高层</span><br></pre></td></tr></table></figure><p>IP是一种<code>无连接</code>和<code>不可靠</code>的协议。它不保证包到达的顺序和发送的顺序一致。也不保证不会重复发送和到达接收者。网络的可靠性由如TCP一样的可靠传输层协议维护。</p><p>TCP是一种面向连接的、可靠的传输协议。 它需要先建立连接，后传输数据。</p><p>TCP通过<code>三次握手</code>建立连接，通过<code>四次挥手</code>终止连接</p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol><li>客户端向服务器发送一个带有标志位<code>SYN</code>的数据包，表明自己希望与服务器建立连接。 客户端的TCP状态变为<code>SYN_SENT</code></li><li>服务器回复一个带有标志位<code>SYN</code>和<code>ACK</code>的数据包，表示同意建立连接。 服务器的TCP状态变为<code> SYN_RECEIVED</code></li><li>客户端接收到服务器的<code>SYN-ACK</code>包后，回应一个<code>ACK</code>包，表示连接建立。 服务器和客户端的TCP状态都变为<code>ESTABLISHED</code>，连接建立。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三次握手</span><br><span class="line">服务器: LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED</span><br><span class="line">客户端:     CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED</span><br></pre></td></tr></table></figure><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><ol><li>主动方向被动方发送一个带标志位<code>FIN</code>的数据包，表示自己想要终止连接。 主动方进入<code>FIN_WAIT_1</code>状态。</li><li>被动方收到<code>FIN</code>包，回应一个<code>ACK</code>包，表示确认收到关闭请求。 被动关闭方进入<code>CLOSE_WAIT</code>状态。 主动方接收ACK后进入<code>FIN_WAIT_2</code>状态</li><li>被动方在数据发送完毕后，向主动方发送一个带<code>FIN</code>标识位的数据包，表示被动方也要终止连接。 被动方进入<code>LAST_ACK</code>状态。</li><li>主动方收到<code>FIN</code>包后，向被动方发送一个<code>ACK</code>包，并进入<code>TIME_WAIT</code>状态。被动方接收<code>ACK</code>后终止连接，主动方一段时间后终止连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                        发送FIN          接收ACK        接收FIN并发送ACK</span><br><span class="line">四次挥手                    |             |             |</span><br><span class="line">主动方:     ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</span><br><span class="line">被动方:     ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK   -&gt; CLOSED</span><br><span class="line">                         |              |           |</span><br><span class="line">                        接收FIN,回应ACK  数据发送完毕   接收ACK </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP&amp;#x2F;IP协议是一个分层联网协议。它包含IP和位于其上的其他协议层。&lt;/p&gt;
&lt;p&gt;TCP&amp;#x2F;IP协议具有一个重要原则——&lt;strong&gt;封装&lt;/strong&gt;。其关键概念为：低层不会对高层传来的信息进行解释。&lt;/p&gt;
&lt;p&gt;当信息从高层传向低层，会加一</summary>
      
    
    
    
    
    <category term="网络编程" scheme="http://aetherance.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>cout和printf差异</title>
    <link href="http://aetherance.github.io/2025/02/01/diff-cout-printf/"/>
    <id>http://aetherance.github.io/2025/02/01/diff-cout-printf/</id>
    <published>2025-01-31T17:23:24.000Z</published>
    <updated>2025-02-03T16:52:03.071Z</updated>
    
    <content type="html"><![CDATA[<p>在并发程序中调用<code>cout</code>和<code>printf()</code>时可以发现它们的微小差异</p><p>多个线程同时打印时,<code>cout</code>的打印通常是混乱的，而<code>printf()</code>的打印总是完整的</p><p>例如:并发打印以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is Task A</span><br><span class="line">Here is Task B</span><br></pre></td></tr></table></figure><p>cout可能会打印成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThiHere is is Ta Task Bsk A</span><br></pre></td></tr></table></figure><p>而printf()总是完整地打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is Task A</span><br><span class="line">Here is Task B</span><br></pre></td></tr></table></figure><p><strong>C++cout是基于流(Stream)实现的</strong></p><p>C++最常用的头文件<code>&lt;iostream&gt;</code>定义了<code>ostream</code>和<code>istream</code>两个流,cout是<code>ostream</code>流的全局对象</p><p>cout内部具有缓冲机制，要输出至标准输出的数据先写入cout对象内部的缓冲区，当缓冲区满时或手动刷新时会输出。</p><p>cout默认为行缓冲，<code>endl</code>也会使缓冲区清空，这个行为也会消耗一定的性能。</p><p>基于其特性，<code>cout</code>并不是一次性将所有内容输出完的，所以不适合在并发输出环境使用。并且这个因素也会使cout的性能有所降低。</p><p><code>printf()</code>会将处理后的字符串一起打印到屏幕上，不会出现混乱。</p><p>在Linux&#x2F;Unix系统，<code>cout</code>和<code>printf()</code>都是通过<code>write()</code>将数据写入<code>STDOUT_FILENO</code>来实现输出效果的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在并发程序中调用&lt;code&gt;cout&lt;/code&gt;和&lt;code&gt;printf()&lt;/code&gt;时可以发现它们的微小差异&lt;/p&gt;
&lt;p&gt;多个线程同时打印时,&lt;code&gt;cout&lt;/code&gt;的打印通常是混乱的，而&lt;code&gt;printf()&lt;/code&gt;的打印总是完整的&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AVL-Tree</title>
    <link href="http://aetherance.github.io/2025/01/29/AVL-Tree/"/>
    <id>http://aetherance.github.io/2025/01/29/AVL-Tree/</id>
    <published>2025-01-29T15:56:46.000Z</published>
    <updated>2025-01-29T17:33:27.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>链表较低的查找效率推动了二叉搜索树的诞生。二叉搜索树可以以对数级别的时间复杂度进行查找。</p><p>然而二叉搜索树在某些特定情况时(数据有序插入)会退化成类似于链表的结构，导致其搜索时的时间复杂度变为O(n)。</p><p>AVL树可以解决二叉树搜索树退化的问题。 它通过判断二叉树<strong>是否失衡</strong>，并在失衡时通过<strong>旋转</strong>将失衡的二叉树置为平衡状态，以防止其变为链表。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>AVL树的旋转方式有两种 —— 左旋和右旋</p><p>左旋使失衡节点(左右子树高度差的绝对值大于1的节点)围绕将成为新根的节点向左(逆时针)旋转，成为新根节点的左孩子，如果新根节点已经有了左孩子，则将其插到失衡节点的右边。</p><p>右旋使失衡节点(左右子树高度差的绝对值大于1的节点)围绕将成为新根的节点向右(顺时针)旋转，成为新根节点的右孩子，如果新根节点已经有了右孩子，则将其插到失衡节点的左边。</p><p>AVL树引入平衡因子的概念描述树的平衡状态。平衡因子是左边的节点高度减右边的节点高度。</p><p>AVL树有四种失衡状态</p><ol><li><strong>LL型</strong> 失衡节点的平衡因子是2 其<em>左</em>孩子的平衡因子是1 需要右旋</li><li><strong>RR型</strong> 失衡节点的平衡因子是-2 其<em>右</em>孩子的平衡因子是-1 需要左旋</li><li><strong>LR型</strong> 失衡节点的平衡因子是2 其<em>左</em>孩子的平衡因子是-1 需要先左旋左孩子再右旋失衡节点</li><li><strong>RL型</strong> 失衡节点的平衡因子是-2 其<em>右</em>孩子的平衡因子是1 需要先右旋右孩子再左旋失衡节点</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVL树节点实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    Node * left;</span><br><span class="line">    Node * right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node::<span class="built_in">Node</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(Node * target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取树的高度 (处理nullptr)</span></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(Node * target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    target-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(target-&gt;left),<span class="built_in">getHeight</span>(target-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(Node * target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取平衡因子</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(target-&gt;left) - <span class="built_in">getHeight</span>(target-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>遍历</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用中序遍历以验证二叉搜索树的性质没有被破坏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;left);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>旋转</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LeftRotate</span><span class="params">(Node ** root)</span> </span>&#123;</span><br><span class="line">    Node * new_root = (*root)-&gt;right;   <span class="comment">// 新根节点</span></span><br><span class="line">    Node * T = new_root-&gt;left;  <span class="comment">// 冲突子树</span></span><br><span class="line"></span><br><span class="line">    new_root-&gt;left = *root;</span><br><span class="line">    (*root)-&gt;right = T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">updateHeight</span>(*root);    <span class="comment">// 更新高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(new_root);</span><br><span class="line"></span><br><span class="line">    *root = new_root;    <span class="comment">// 改变根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightRotate</span><span class="params">(Node ** root)</span> </span>&#123;</span><br><span class="line">    Node * new_root = (*root)-&gt;left;</span><br><span class="line">    Node * T = new_root-&gt;right;</span><br><span class="line"></span><br><span class="line">    new_root-&gt;right = (*root);</span><br><span class="line">    (*root)-&gt;left = T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">updateHeight</span>(*root);</span><br><span class="line">    <span class="built_in">updateHeight</span>(new_root);</span><br><span class="line"></span><br><span class="line">    *root = new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>插入</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(Node ** root,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到合适空位置后插入</span></span><br><span class="line">    <span class="keyword">if</span>(*root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重复插入</span></span><br><span class="line">    <span class="keyword">if</span>(val == (*root)-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断大小，递归寻找</span></span><br><span class="line">    <span class="keyword">if</span>(val&lt;(*root)-&gt;val) &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(&amp;(*root)-&gt;left,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val&gt;(*root)-&gt;val) &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(&amp;(*root)-&gt;right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(*root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(*root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否失衡并旋转</span></span><br><span class="line">    <span class="keyword">if</span>(balance == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getBalance</span>((*root)-&gt;left) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">RightRotate</span>(root);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalance</span>((*root)-&gt;left) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LeftRotate</span>(&amp;(*root)-&gt;left);</span><br><span class="line">            <span class="built_in">RightRotate</span>(&amp;(*root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(balance == <span class="number">-2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getBalance</span>((*root)-&gt;right) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">RightRotate</span>(&amp;(*root)-&gt;right);</span><br><span class="line">            <span class="built_in">LeftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">getBalance</span>((*root)-&gt;right) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LeftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>删除</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除左右都不为空时的节点时需要获取左子树最大值节点 (或右子树最小节点)</span></span><br><span class="line"><span class="function">Node * <span class="title">findLeftMax</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">    Node * max = root-&gt;left;</span><br><span class="line">    <span class="keyword">while</span> (max &amp;&amp; max-&gt;right) &#123;</span><br><span class="line">        max = max-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node ** root,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止空指针解引用</span></span><br><span class="line">    <span class="keyword">if</span>(*root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找</span></span><br><span class="line">    <span class="keyword">if</span>(val&lt;(*root)-&gt;val) &#123;</span><br><span class="line">        <span class="built_in">remove</span>(&amp;(*root)-&gt;left,val); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; (*root)-&gt;val) &#123;</span><br><span class="line">        <span class="built_in">remove</span>(&amp;(*root)-&gt;right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到对应值，开始删除</span></span><br><span class="line">        <span class="comment">// 删除有三种情况</span></span><br><span class="line">        <span class="comment">// 1.左右都是空 直接删除即可</span></span><br><span class="line">        <span class="comment">// 2.左右有一个是空 和链表删除类似</span></span><br><span class="line">        <span class="comment">// 3.左右都不是空 要找到子树中刚好比该节点大或小的节点 即左子树的最大节点或者右子树的最小节点</span></span><br><span class="line">        <span class="comment">// 此处用 findLeftMax找到左子树的最大节点，然后用其值替换删除节点，最后删除左子树的最大节点</span></span><br><span class="line">        Node * temp = *root;</span><br><span class="line">        <span class="keyword">if</span>(!(*root)-&gt;left &amp;&amp; !(*root)-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">delete</span> *root;</span><br><span class="line">            *root = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*root)-&gt;left &amp;&amp; !(*root)-&gt;right) &#123;</span><br><span class="line">            *root = (*root)-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*root)-&gt;right &amp;&amp; !(*root)-&gt;left) &#123;</span><br><span class="line">            *root = (*root)-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node * leftMax = <span class="built_in">findLeftMax</span>(*root);</span><br><span class="line">            (*root)-&gt;val = leftMax-&gt;val;</span><br><span class="line">            <span class="built_in">remove</span>(&amp;(*root)-&gt;left,leftMax-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*root == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="comment">// 删除后可能出现空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">updateHeight</span>(*root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与插入类似的失衡判断</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(*root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(balance == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> lb = <span class="built_in">getBalance</span>((*root)-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(lb == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">RightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lb == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LeftRotate</span>(&amp;(*root)-&gt;left);</span><br><span class="line">            <span class="built_in">RightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(balance == <span class="number">-2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> rb = <span class="built_in">getBalance</span>((*root)-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rb == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LeftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rb == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">RightRotate</span>(&amp;(*root)-&gt;right);</span><br><span class="line">            <span class="built_in">LeftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Aetherance/DataStruct/blob/master/Tree/MyAVL.cpp">完整代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;链表较低的查找效率推动了二叉搜索树的诞生。二叉搜索树可以以对数级别的时间复杂度进行查找。&lt;/p&gt;
&lt;p&gt;然而二叉搜索树在某些特定情况时(数据</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://aetherance.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>哈希表原理及实现</title>
    <link href="http://aetherance.github.io/2025/01/25/HashTable/"/>
    <id>http://aetherance.github.io/2025/01/25/HashTable/</id>
    <published>2025-01-25T13:06:56.000Z</published>
    <updated>2025-01-26T09:37:19.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>哈希表通过键值(<code>key</code>)来查找数据(<code>value</code>) 通常可以以极低的时间复杂度查找数据。</p><p>哈希表的底层通常是支持随机访问的容器。由于键值和数据值一一对应，哈希表支持以<code>table[key]</code>的形式访问数据。</p><p>为了减少空白位置造成的空间浪费，哈希表通过哈希函数将键映射到表中的一个索引位置。 <a href="https://blog.csdn.net/qq_20853741/article/details/112464621">哈希函数</a></p><p>当两个不同的键通过哈希函数映射到相同的数组索引位置时，就会发生哈希冲突。</p><p>解决哈希冲突的常用方法：</p><ol><li>链式地址法</li><li>开放定址法</li></ol><p>链式法在哈希表的每个位置存储一个链表，冲突的元素会被插入链表。</p><p>开放定址法会在数组中找一个空位存放冲突的元素。</p><p>本文实现的哈希表使用除留余数法映射键值，使用链式地址法处理哈希冲突。</p><h1 id="哈希表类的使用"><a href="#哈希表类的使用" class="headerlink" title="哈希表类的使用"></a>哈希表类的使用</h1><p>通过哈希表的构造函数创建一个哈希表对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hashtable <span class="title">h1</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">// 创建一个大小为传入参数Size的哈希表</span></span><br></pre></td></tr></table></figure><p>调用哈希表对象的成员函数<code>Insert</code>向哈希表内插入一个节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h<span class="number">1.</span><span class="built_in">Insert</span>(<span class="number">10</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>如果键值已经存在，将替换原来的值。</p><p><code>GetValue()</code>会返回哈希表中键值(key)对应的值(value) 如果键值不存在，则返回-1</p><p><code>GetKeyNode()</code>会返回对应键值的节点(Hnode) 如果键值不存在，返回<code>nullptr</code></p><p>哈希表类重载了<code>[]</code>操作符，可以通过<code>h1[key]</code>的形式访问数据</p><p>哈希表类的析构函数会在对象销毁时自动释放对象开辟的内存。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>哈希表类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hashtable</span>(<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">hashtable</span>();</span><br><span class="line">    <span class="function">Hnode* <span class="title">GetKeyNode</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Hnode**data;</span><br><span class="line">    <span class="type">int</span> HashNum;</span><br><span class="line">    <span class="type">int</span> Size;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表构造函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hashtable::<span class="built_in">hashtable</span>(<span class="type">int</span> Size) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> Hnode*[Size]();</span><br><span class="line">    HashNum = Size;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Size = Size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个哈希表对象时，构造函数会根据传入的参数Size开辟底层数组data，并初始化成员变量HashNum和Size</p><p>本实现使用除留余数法实现哈希函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hashtable::hash</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % HashNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetKeyNode()</code>函数在key对应的序列中查找并返回对应key值的节点。如果没有找到，返回<code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Hnode*<span class="title">hashtable::GetKeyNode</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    Hnode * target = data[<span class="built_in">hash</span>(key)];</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (target-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;target-&gt;key!=key) &#123;</span><br><span class="line">        target = target-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target-&gt;key == key ? target : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Insert()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hashtable::Insert</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    Hnode * key_node;</span><br><span class="line">    <span class="keyword">if</span>(key_node = <span class="built_in">GetKeyNode</span>(key)) &#123;</span><br><span class="line">        key_node-&gt;key = key;</span><br><span class="line">        key_node-&gt;val = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key_node = data[<span class="built_in">hash</span>(key)];</span><br><span class="line">    Hnode * newnode = <span class="built_in">BuyNewnode</span>(key,val);</span><br><span class="line">    <span class="keyword">if</span>(key_node==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        data[<span class="built_in">hash</span>(key)] = newnode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (key_node-&gt;next) &#123;</span><br><span class="line">        key_node = key_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    key_node-&gt;next = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;哈希表通过键值(&lt;code&gt;key&lt;/code&gt;)来查找数据(&lt;code&gt;value&lt;/code&gt;) 通常可以以极低的时间复杂度查找数据。&lt;</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://aetherance.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简单线程池(pthread实现)</title>
    <link href="http://aetherance.github.io/2025/01/18/pthreads-pool/"/>
    <id>http://aetherance.github.io/2025/01/18/pthreads-pool/</id>
    <published>2025-01-18T09:29:39.000Z</published>
    <updated>2025-02-01T09:36:40.568Z</updated>
    
    <content type="html"><![CDATA[<p>每次创建和销毁线程都会消耗一定的系统资源，且线程创建过程也有一定的开销。</p><p>线程池可以<strong>复用</strong>线程，提高程序的性能和效率，并且节省系统资源。</p><p>以下是一个基于<code>POSIX线程</code>,用<code>C++</code>编写的线程池实现。</p><p><a href="https://plan.xiyoulinux.com/plan/simple-thread-pool-challenge/">XiyouLinuxGroup Threadpool Plan</a></p><h1 id="线程池类定义"><a href="#线程池类定义" class="headerlink" title="线程池类定义"></a>线程池类定义</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">worker</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">submit</span><span class="params">(function&lt;<span class="type">void</span>()&gt;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> Stop;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt;threads;</span><br><span class="line">    queue&lt;function&lt;<span class="type">void</span>()&gt;&gt;TaskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> task_cond;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_wait_all;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_wait_all;</span><br><span class="line">    <span class="type">int</span> threadsActive;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="线程池工作过程"><a href="#线程池工作过程" class="headerlink" title="线程池工作过程"></a>线程池工作过程</h1><p><code>threadpool(int);</code>是线程池类的构造函数。当创建一个<code>threadpool</code>对象时，根据传入的参数<code>Size</code>创建指定数目的线程。并完成线程池条件变量和互斥量的初始化以及一些变量的初值设置。</p><p><code>static void * Woker(void *);</code>定义了线程池的核心工作函数。由构造函数创建的线程阻塞在Worker中等待任务队列的更新，若有新任务通过<code>TaskSubmit()</code>提交，阻塞的线程会获得消息，从任务队列<code>front()</code>位置抽取任务开始工作。</p><p>所有的任务都由<code>TaskSubmit()</code>提交，提交一个任务后，该函数内部将任务放入任务队列队尾并通知没有任务的线程执行。</p><p>调用线程池析构函数或<code>Stop</code>成员函数时，线程池会先唤醒所有线程，并等待所有正在工作的线程结束，最后进行锁和条件变量的销毁。</p><h1 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">threadpool::worker</span><span class="params">(<span class="type">void</span> * this_ptr)</span> </span>&#123;</span><br><span class="line">    threadpool * pthis = <span class="built_in">static_cast</span>&lt;threadpool*&gt;(this_ptr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pthis-&gt;mutex);</span><br><span class="line">        <span class="keyword">while</span>(pthis-&gt;TaskQueue.<span class="built_in">empty</span>()&amp;&amp;!pthis-&gt;Stop) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pthis-&gt;task_cond,&amp;pthis-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pthis-&gt;Stop&amp;&amp;pthis-&gt;TaskQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld exited\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pthis-&gt;mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        function&lt;<span class="type">void</span>()&gt;task = pthis-&gt;TaskQueue.<span class="built_in">front</span>();</span><br><span class="line">        pthis-&gt;TaskQueue.<span class="built_in">pop</span>();</span><br><span class="line">        pthis-&gt;threadsActive ++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pthis-&gt;mutex);</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pthis-&gt;mutex);</span><br><span class="line">        pthis-&gt;threadsActive --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pthis-&gt;TaskQueue.<span class="built_in">empty</span>()&amp;&amp;!pthis-&gt;threadsActive)</span><br><span class="line">            <span class="built_in">pthread_cond_broadcast</span>(&amp;pthis-&gt;cond_wait_all);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pthis-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static_cast</code>将<code>void *</code>类型的指针转化为<code>threadpool*</code>类型的指针并用<code>thispool</code>来接收，便于调用线程池对象中的成员函数。</p><p>最外层的<code>while()</code>循环保证了线程在执行完一个任务后继续回到<code>pthread_cond_wait</code>处等待下一个任务。</p><p>线程在<code>pthread_cond_wait</code>语句处释放互斥量并等待条件变量的改变。</p><p>如果任务队列里有任务，Worker会从任务队列里取出一个任务并用一个函数对象接收，然后执行这个函数对象</p><p><code>ThreadsActive</code>是实现线程池等待所有线程结束的关键。每次任务结束Worker会检查是否满足线程池关闭条件(任务是否都执行完了)，如果满足则通知主线程可以Stop。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">threadpool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">TaskSubmit</span>([]()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TASK A&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">TaskSubmit</span>([]()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TASK B&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">TaskSubmit</span>([]()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TASK C&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">TaskSubmit</span>([]()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TASK D&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">TaskSubmit</span>([]()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TASK E&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">Stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TASK A</span><br><span class="line">TASK B</span><br><span class="line">TASK C</span><br><span class="line">TASK D</span><br><span class="line">TASK E</span><br></pre></td></tr></table></figure><p>用线程池处理阶乘计算任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span> <span class="comment">// 采用boost库处理大数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::multiprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 祖传代码</span></span><br><span class="line"><span class="function">cpp_int <span class="title">c</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">c</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ostringstream oss;</span><br><span class="line">    oss&lt;&lt;<span class="built_in">c</span>(n);  <span class="comment">// 将计算结果输入流oss</span></span><br><span class="line">    <span class="type">char</span> * result = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">204800</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(result,oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>()); <span class="comment">//转换成C形式 便于用printf打印</span></span><br><span class="line">    <span class="comment">// 为什么要用printf打印 </span></span><br><span class="line">    <span class="comment">// printf打印时会将格式化后的整体一起打印</span></span><br><span class="line">    <span class="comment">// 而cout会将要打印的内容放入缓冲区 如果缓冲区满了 会先打印一部分</span></span><br><span class="line">    <span class="comment">// 所以多线程使用cout打印会出现打印混乱的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 的阶乘是 \n %s\n\n&quot;</span>,n,result);</span><br><span class="line">    <span class="keyword">delete</span>[] result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="function">threadpool <span class="title">pool</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++) &#123;</span><br><span class="line">        pool.<span class="built_in">submit</span>([i]() &#123;</span><br><span class="line">            <span class="built_in">Task</span>(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">auto</span> end = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> mstime = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(end - start);</span><br><span class="line">    <span class="keyword">auto</span> stime = <span class="built_in">duration_cast</span>&lt;seconds&gt;(end - start);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;共用时 &quot;</span>&lt;&lt;mstime.<span class="built_in">count</span>()&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;约 &quot;</span>&lt;&lt;stime.<span class="built_in">count</span>()&lt;&lt;<span class="string">&quot; s&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Aetherance/Thread/tree/master/pthread_pool/TaskA">GITHUB</a></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><code>Stop()</code>中等待条件变量的<code>while()</code>退出条件一定同时要满足<strong>任务队列为空</strong>和<strong>当前无任务进行</strong>，否则有可能漏掉一些任务。</p><p>2月1日再编:</p><p>2月1日重构了线程池，改进了线程池的结构，修复了偶尔会触发的死锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每次创建和销毁线程都会消耗一定的系统资源，且线程创建过程也有一定的开销。&lt;/p&gt;
&lt;p&gt;线程池可以&lt;strong&gt;复用&lt;/strong&gt;线程，提高程序的性能和效率，并且节省系统资源。&lt;/p&gt;
&lt;p&gt;以下是一个基于&lt;code&gt;POSIX线程&lt;/code&gt;,用&lt;code&gt;C++</summary>
      
    
    
    
    
    <category term="pthread线程 C++" scheme="http://aetherance.github.io/tags/pthread%E7%BA%BF%E7%A8%8B-C/"/>
    
  </entry>
  
  <entry>
    <title>多线程归并排序与clock()</title>
    <link href="http://aetherance.github.io/2025/01/08/thread-mergersort/"/>
    <id>http://aetherance.github.io/2025/01/08/thread-mergersort/</id>
    <published>2025-01-08T14:47:54.000Z</published>
    <updated>2025-01-14T06:57:47.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程排序"><a href="#多线程排序" class="headerlink" title="多线程排序"></a>多线程排序</h1><p><a href="https://plan.xiyoulinux.com/project/thread/#_2">PLAN</a></p><p>因为归并排序本身具有“分而治之”的思想，很适合用多线程优化，因此选择归并排序。</p><p>首先定义一个vector容器<code>arr</code>来存储要排序的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;arr;</span><br></pre></td></tr></table></figure><p>然后写一个最基础的归并排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> begin,<span class="type">int</span> mid,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">left</span>(arr.<span class="built_in">begin</span>()+begin,arr.<span class="built_in">begin</span>()+mid<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">right</span>(arr.<span class="built_in">begin</span>()+mid<span class="number">+1</span>,arr.<span class="built_in">begin</span>()+end<span class="number">+1</span>);</span><br><span class="line">    left.<span class="built_in">push_back</span>(INT_MIN),right.<span class="built_in">push_back</span>(INT_MIN);</span><br><span class="line">    <span class="type">int</span> Lindex = <span class="number">0</span>,Rindex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = begin;i&lt;=end;i++)    </span><br><span class="line">        arr[i] = (left[Lindex]&gt;right[Rindex]?left[Lindex++]:right[Rindex++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin==end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(begin,mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(mid<span class="number">+1</span>,end);</span><br><span class="line">    <span class="built_in">Merge</span>(arr,begin,mid,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义结构体Args用于传参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将函数MergeSort改为多线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(Args* args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = args-&gt;begin,end = args-&gt;end;</span><br><span class="line">    <span class="keyword">if</span>(begin==end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">pthread_t</span> ptd1,ptd2;</span><br><span class="line"></span><br><span class="line">    Args Largs = &#123;begin,mid&#125;,Rargs = &#123;mid<span class="number">+1</span>,end&#125;;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd1,<span class="literal">NULL</span>,(<span class="type">void</span>*(*)(<span class="type">void</span>*))MergeSort,&amp;Largs);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd2,<span class="literal">NULL</span>,(<span class="type">void</span>*(*)(<span class="type">void</span>*))MergeSort,&amp;Rargs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(ptd1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(ptd2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">Merge</span>(arr,begin,mid,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataGenerate()</code>函数负责随机数的生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DataGenerate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">size_t</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)</span><br><span class="line">        arr.<span class="built_in">push_back</span>(<span class="built_in">rand</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是线程越多排序速度越快，并且创建过多线程会导致段错误，所以需要对线程的数目加以限制。<br>只有数据量大的时候需要创建新线程。当数据量已经较小，采用普通递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (end - begin &lt;= DataSize/<span class="number">1000</span>) &#123;</span><br><span class="line">        Args Larg = Args&#123;begin, mid&#125;;</span><br><span class="line">        Args Rarg = Args&#123;mid + <span class="number">1</span>, end&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MergeSort</span>(&amp;Larg);</span><br><span class="line">        <span class="built_in">MergeSort</span>(&amp;Rarg);</span><br><span class="line">        <span class="built_in">Merge</span>(arr, begin, mid, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用C++<code>chrono</code>库验证</p><p>结果(数据量1千万)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单4.19649s</span><br><span class="line">多0.568866s</span><br></pre></td></tr></table></figure><p>多线程排序显著快于单线程排序。</p><p>注：<code>clock()</code>不能准确记录多线程排序的耗时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单线程-&gt;<span class="number">4070385</span>&lt;-</span><br><span class="line">多线程-&gt;<span class="number">5175620</span>&lt;-   <span class="comment">// clock_t 记录的时间</span></span><br></pre></td></tr></table></figure><h1 id="clock-的本质"><a href="#clock-的本质" class="headerlink" title="clock()的本质"></a>clock()的本质</h1><p>clock()是<code>the CPU time used so far</code>即占用的CPU时间</p><p>而多线程程序中多个线程同时运行时，每个线程占用的CPU时间都会被记录。并且线程的创建等也会占用CPU时间，因此clock()返回的时间多线程必定大于单线程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程排序&quot;&gt;&lt;a href=&quot;#多线程排序&quot; class=&quot;headerlink&quot; title=&quot;多线程排序&quot;&gt;&lt;/a&gt;多线程排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://plan.xiyoulinux.com/project/thread/#_2&quot;&gt;P</summary>
      
    
    
    
    
    <category term="线程" scheme="http://aetherance.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pthread_notes</title>
    <link href="http://aetherance.github.io/2025/01/07/pthread-note/"/>
    <id>http://aetherance.github.io/2025/01/07/pthread-note/</id>
    <published>2025-01-07T07:13:44.000Z</published>
    <updated>2025-01-14T10:29:20.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程学习笔记"><a href="#线程学习笔记" class="headerlink" title="线程学习笔记"></a>线程学习笔记</h1><h1 id="为什么要使用线程"><a href="#为什么要使用线程" class="headerlink" title="为什么要使用线程"></a>为什么要使用线程</h1><ol><li>线程之间共享全局区和堆内存，这使线程之间的信息共享较进程之间更为方便，代价更小。</li><li>创建进程时使用的系统调用<code>fork()</code>代价高，创建线程使用的系统调用<code>clone()</code>比<code>fork()</code>通常快10倍不止。</li></ol><h1 id="线程共享的属性"><a href="#线程共享的属性" class="headerlink" title="线程共享的属性"></a>线程共享的属性</h1><ol><li>全局内存</li><li>进程ID 父进程ID</li><li>进程组ID与会话ID</li><li>控制终端</li><li>打开的文件描述符</li><li>信号处置</li><li>某些时候的栈 (?)</li><li>…<br>每个线程都有存放局部变量的私有栈。</li></ol><h1 id="Pthreads函数返回值"><a href="#Pthreads函数返回值" class="headerlink" title="Pthreads函数返回值"></a>Pthreads函数返回值</h1><p>与传统函数返回-1代表失败不同的是，所有的Pthreads函数都是返回正值表示失败。</p><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>程序启动时，一个进程中只有一条称为<em>主线程</em>的线程。</p><p>调用<code>pthread_create()</code>将创建一个线程。</p><p><code>pthread_create()</code>的第一个参数是一个指向<code>pthread_t</code>类型的指针,线程ID将被写入该类型中</p><p>第二个参数是一个 const pthread _attr_t类型的指针 用于定制不同的线程属性，通常直接设为<code>NULL</code></p><p>第三个参数是一个函数指针，指向线程的start函数。线程从此函数开始运行。</p><p>第四个函数是一个指向start函数参数的指针。</p><h1 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h1><ul><li>主线程调用<code>main</code>函数中的<code>return</code>语句会终止所有线程</li><li>任意线程调用<code>exit()</code>语句会终止所有线程</li><li>线程执行<code>start</code>函数的<code>return</code>语句只会终止调用的线程自身</li><li>线程调用<code>pthread_exit()</code>语句<code>只</code>会终止调用的线程自身，不论这个线进程是不是主线程</li><li>调用<code>pthread_cancle()</code>取消线程</li></ul><h1 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h1><p>在pthread函数中,线程ID由<code>pthread_t</code>定义。</p><p><code>pthread_t</code>是一种<em>不透明数据类型</em> 在Linux实现中,pthread_t是无符号长整形,而在其他实现中有可能是指针或者结构体。</p><p>因此，对于pthread_t的比较，应该使用pthread_equal函数而不是C语言中的<code>==</code>等操作符。</p><h1 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h1><p>函数<code>pthread_join</code>会等待一个线程，直至其终止。线程终止时会立即返回。这种操作被称为<em>连接</em></p><p>若函数<code>pthread_join</code>的第二个参数<code>retval</code>为一非空指针，将会保存线程终止时返回值的拷贝。即保存了线程调用<code>return</code>或<code>pthread_exit</code>时所指定的值</p><p>向函数<code>pthread_join</code>传入已经join过的线程id的结果未知</p><p>调用<code>pthread_join</code>的线程会阻塞，直到对应线程执行完毕 相当于对进程使用<code>wait()</code>系统调用 不同的是，<code>wait()</code>只能由父进程调用</p><p>为了防止线程成为<code>僵尸线程</code>，一定要对其进行join操作</p><h1 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h1><p>线程具有可连接和已分离两个状态。调用<code>pthread_detach()</code>可以使线程分离，即使其不可连接。</p><p>线程一旦处于分离状态，便不能再调用join来与其连接，也不能再重使其返回可连接状态。<code>pthread_detach()</code>的调用是不可逆的。</p><p>不论线程是否已分离，调用<code>exit()</code>或主进程执行<code>return</code>时，所有线程都会立即终止。</p><h1 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h1><p>利用<code>pthread_create()</code>的第二个参数可以设置线程的属性。</p><h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><p>为了防止两个线程同时对某一共享资源进行修改，或者同时对其进行读写操作，要使用互斥量来确保同时只有一个线程访问共享资源。</p><p>例如，对于一个线程AB都可访问的全局变量，线程A在访问时将其‘锁’住，可以防止B访问，减少错误的发生。<br>果父线程没有调用 pthread_join()，该线程的资源仍然不会被完全回收，这可能导致僵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mtx,<span class="literal">NULL</span>);  <span class="comment">// 动态初始化</span></span><br></pre></td></tr></table></figure><p><code>pthread_mutex_lock()</code>会尝试获取一个互斥量，如果该互斥量已被其他线程锁定，本线程会阻塞等待，直到对应线程对互斥量解锁。<code>pthread_mutex_trylock()</code>与之类似，不同的是<code>trylock</code>在互斥量已被锁定的情况下不会等待，而是返回一个错误码<code>EBUSY</code></p><p><code>pthread_mutex_unlock()</code>会对已锁定的互斥量解锁。不要忘记解锁互斥量，也不要对一个没有锁定的互斥量解锁。</p><p>静态初始化的互斥量总为<code>默认属性</code> 而动态初始化的互斥量可以被定义为其他属性</p><p>调用<code>pthread_mutex_init()</code>来动态初始化一个互斥量,动态初始化的互斥量应该最终被调用的<code>pthread_mutex_destroy()``销毁</code></p><p>应该对所有可能进入临界区的线程使用互斥量，以保证临界区内的线程操作是线程安全的。</p><p>同一线程不应对普通互斥量加锁两次。</p><p>设定了<code>PTHREAD_MUTEX_RECURSIVE</code>属性的互斥量是<code>递归互斥量</code>，可以多次加锁。但是也必须解对应次数的锁才能被另一线程获取。否则，将导致“死锁”。</p><p>互斥量确保只有一个线程可以进入临界区</p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>互斥量防止多个线程同时访问同一共享变量。而条件变量可以使线程阻塞(等待)直到某一条件的改变。</p><p>条件变量的类型是<code>pthread_t</code> 条件变量的初始化与互斥量类似。条件变量要和互斥量一起使用。</p><h2 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h2><p><code>pthread_cond_wait()</code>函数使调用的线程等待，直到对应条件变量改变。</p><p><code>pthread_cond_wait()</code>的调用应处于锁和解锁之间。 <code>pthread_cond_wait()</code>传入的互斥量在该函数调用之前一定是已经被锁定的，否则可能会产生错误。</p><p>必须由一个循环语句来控制<code>pthread_cond_wait()</code>的调用，因为可能存在<code>假唤醒</code> 即线程被唤醒的时候条件未改变，所以应该一直检测</p><h2 id="通知条件变量"><a href="#通知条件变量" class="headerlink" title="通知条件变量"></a>通知条件变量</h2><p><code>pthread_cond_signal()</code>和<code>pthread_cond_broadcast()</code>都可以通知条件变量使之状态改变。</p><p>两者的区别是：前者将随机唤醒至少一条线程，而后者会唤醒所有的线程。</p><h1 id="线程安全和每线程存储"><a href="#线程安全和每线程存储" class="headerlink" title="线程安全和每线程存储"></a>线程安全和每线程存储</h1><p>线程安全函数 即能在多线程调用时保证线程安全的函数。</p><h2 id="可重入和不可重入函数"><a href="#可重入和不可重入函数" class="headerlink" title="可重入和不可重入函数"></a>可重入和不可重入函数</h2><p>由于互斥量的加锁和解锁也具有一定开销，所以使用临界区实现线程安全的效率并不高。所以可重入函数的使用具有一定意义。</p><p>可重入函数不访问全局或静态变量，其信息都存在调用者分配的缓冲区里。然而，不是所有函数都可改写为可重入函数。</p><p>例如 <code>malloc()</code>类函数必须访问全局变量。它的线程安全是由互斥量实现的。</p><p>一些函数会返回一个指向静态分配的缓冲区的指针，同样不可改写为可重入函数。</p><p>一些不可重入函数具有“可重入的替身”，以后缀<code>_r</code>结尾。 例如 <code>readdir_r()</code> <code>rand_r()</code> <code>strtok_r()</code></p><h2 id="一次性初始化"><a href="#一次性初始化" class="headerlink" title="一次性初始化"></a>一次性初始化</h2><p>对于库函数，不能指望在main函数中初始化一些量，而这些量又必须且只能初始化一次。此时需要一个对任意调用线程，都只进行一次量的初始化的库函数。</p><p><code>pthread_once()</code>就有这样的功能。</p><p><code>pthread_once()</code>的第一个参数是指向<code>pthread_once_t</code>类型的地址<code>once_control</code>,通过<code>once_control</code>的状态可判断是否是第一次执行。</p><p>第二个参数是一个指向自定义的函数的指针。该函数无参无返。初始化的函数应该置于该函数体内。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    // 将初始化函数置于此处</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pthread_once_t 的变量应静态初始化。</p><h2 id="线程特有数据"><a href="#线程特有数据" class="headerlink" title="线程特有数据"></a>线程特有数据</h2><p>线程特有数据使得函数为每个调用线程都创建一个特有缓冲区，维护一份线程的副本。这个副本是长期存在的。函数可以向每个调用线程返回各自的缓冲区。</p><p>使用线程特有数据的函数会为调用线程分配单独的存储，且只在该线程初次调用时分配一次。</p><p>在同一线程的后续调用该函数时，都会获取初次调用所分配的缓冲区地址。</p><h1 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h1><p><code>pthread_cancel()</code>会向线程发送一个取消请求，该过程中，发送信号的线程不会等待被发送信号的线程。</p><h2 id="取消状态及类型"><a href="#取消状态及类型" class="headerlink" title="取消状态及类型"></a>取消状态及类型</h2><p><code>pthread_setcancelstate()</code>和<code>pthread_setcanceltpye()</code>会设定标志，控制线程对线程取消的响应过程。</p><p><code>pthread_setcancelstate()</code>和<code>pthread_setcanceltpye()</code>会将线程的取消性状态设置为第一个参数对应的值。<br>线程原有的取消类型将返回到第二个参数指向的地方。</p><p>使用<code>fork()</code>创建新进程时，子进程会继承调用线程的取消性及状态。某线程调用<code>exec()</code>会将取消状态和取消类型重置为默认值。</p><p>当取消类型为<code>PTHREAD_CANCEL_DEFERED</code>时，取消请求将挂起，直到到达取消点。（延迟取消）</p><p><code>pthread_testcancel()</code>可以产生一个取消点</p><p>线程的默认取消属性是可以取消，默认取消类型是延迟取消。</p><p>收到取消信息的启用了取消性状态并延迟取消的线程，应该由其他线程join()，否则可能变为<code>僵尸线程</code></p><h2 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h2><p>每个线程拥有一个清理函数栈，栈中存放清理函数指针。当线程取消时，会从栈顶开始执行清理函数，当所有函数都执行完毕时，线程终止。</p><p>使用<code>pthread_cleanup_push()</code>来向栈中增加清理函数。</p><p>使用<code>pthread_cleanup_pop()</code>来删除清理函数。 该函数只有一个参数<code>execute</code> 如果其非0 那么这个清理函数一定会被执行。</p><p><code>push()</code>与<code>pop()</code>必须同处于同一代码块({}) 才能正确执行。 <strong>每一个push都得对应一个pop</strong> 并且pop的时候才会执行。</p><p>调用<code>pthread_exit()</code>终止线程会导致清理函数栈中的所有函数被执行，而执行<code>return</code>语句不会。(?)</p><h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="线程和exec"><a href="#线程和exec" class="headerlink" title="线程和exec()"></a>线程和<code>exec()</code></h2><p>任意线程调用了<code>exec()</code>函数，除调用线程以外的所有线程都会消失。既不会对线程特有数据执行解构函数，也不会执行清理函数。该线程的互斥量和条件变量都会立即消失。并且最终的线程ID是不确定的。</p><h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork()"></a>线程和<code>fork()</code></h2><p>任意线程调用了<code>fork()</code>函数，除调用线程以外的所有线程都会消失。既不会对线程特有数据执行解构函数，也不会执行清理函数。调用fork()的线程ID会被复制到新进程中。互斥量和条件变量都得以保留，然而，互斥量和条件变量的状态不会刷新，可能会引起许多问题。</p><p>可能会导致子进程的内存泄漏。</p><p>如果在fork()后马上调用exec()，可能会解决非主线程调用<code>fork()</code>导致的问题。或者，调用<code>pthread_atfork()</code>也可以解决。</p><h1 id="多线程使用笔记"><a href="#多线程使用笔记" class="headerlink" title="多线程使用笔记"></a>多线程使用笔记</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>在多线程的使用中，可能会出现主线程先结束使其他线程也终止的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func()调用  线程ID -&gt; &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> ptd;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd,<span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只输出了主线程的调用</p><p>需要让主线程’等待’其他线程结束。 可以使用 <code>pthread_join()</code>或让主线程sleep 使用while()等待也是可行的 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func()调用  线程ID -&gt; &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> ptd;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd,<span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_join</span>(ptd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//sleep(3);</span></span><br><span class="line">    <span class="comment">//while(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以调用<code>pthread_exit</code>让主线程退出，其他线程会继续运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func()调用  线程ID -&gt; &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">thread_func</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> ptd;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd,<span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join和detach"><a href="#join和detach" class="headerlink" title="join和detach"></a>join和detach</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;test()调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> ptd;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd,<span class="literal">NULL</span>,(<span class="type">void</span>*(*)(<span class="type">void</span>*))pthread_test,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(ptd);</span><br><span class="line">    <span class="built_in">pthread_join</span>(ptd,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pthread_exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个已经detach的线程是无法join的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;test()调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> ptd;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ptd,<span class="literal">NULL</span>,(<span class="type">void</span>*(*)(<span class="type">void</span>*))pthread_test,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(ptd);</span><br><span class="line">    <span class="built_in">pthread_join</span>(ptd,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pthread_exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程学习笔记&quot;&gt;&lt;a href=&quot;#线程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;线程学习笔记&quot;&gt;&lt;/a&gt;线程学习笔记&lt;/h1&gt;&lt;h1 id=&quot;为什么要使用线程&quot;&gt;&lt;a href=&quot;#为什么要使用线程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Linux系统编程" scheme="http://aetherance.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ Note</title>
    <link href="http://aetherance.github.io/2025/01/05/C++Note/"/>
    <id>http://aetherance.github.io/2025/01/05/C++Note/</id>
    <published>2025-01-05T06:49:15.000Z</published>
    <updated>2025-01-08T14:41:20.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPP-LEARNING"><a href="#CPP-LEARNING" class="headerlink" title="CPP LEARNING"></a>CPP LEARNING</h1><h2 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h2><ol><li>使用new来开辟内存空间 delete来删除已开辟的空间</li><li>new返回的是该数据类型的指针</li><li>使用delete释放数组时需要用 delete[]</li></ol><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><ol><li>引用必须要初始化</li><li>初始化后引用就不能改了</li><li>不要返回局部变量的引用</li><li>返回值是引用的函数可以作左值</li><li>引用的本质在C++内部的实现就是一个指针常量</li><li>可以用const修饰防止形参修改实参</li></ol><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="1-函数的默认参数"><a href="#1-函数的默认参数" class="headerlink" title="1. 函数的默认参数"></a>1. 函数的默认参数</h3><ol><li>C++的函数可以有默认参数，但是从第一个默认参数开始，后面的参数都必须有默认值</li><li>函数的声明和实现只能有一个有默认参数</li></ol><h3 id="2-函数的重载"><a href="#2-函数的重载" class="headerlink" title="2.函数的重载"></a>2.函数的重载</h3><ol><li>C++的函数可以同名，提高函数的复用性。</li><li>函数的重载必须在同一个作用域下，且名称相同。</li><li>函数的重载要求满足函数的参数或者类型不同，或者个数不同，或者顺序不同。 <strong>函数的返回值不能做函数重载的条件</strong></li><li>引用可以做函数重载的条件 (const修饰与无const修饰) 传入常量区数据，调用const引用，传入其他数据，调用非const引用。<br>5.当重载函数有默认参数时，默认参数可能会无法重载</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;func2()的调用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;func2()的调用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>func2(int a,int b = 10)</code>具有一个默认参数，这使得func2(10)具有<code>二义性</code></p><hr><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="C-面向对象三大特性-emsp-封装、继承、多态"><a href="#C-面向对象三大特性-emsp-封装、继承、多态" class="headerlink" title="C++ 面向对象三大特性&emsp;封装、继承、多态"></a>C++ 面向对象三大特性&emsp;封装、继承、多态</h2><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h2><h3 id="将属性和行为写在一起，并加入一些权限控制。-————-类"><a href="#将属性和行为写在一起，并加入一些权限控制。-————-类" class="headerlink" title="将属性和行为写在一起，并加入一些权限控制。 ———— 类"></a>将属性和行为写在一起，并加入一些权限控制。 ———— 类</h3><p>与<code>struct</code>不同的是 类——<code>class</code>的权限是默认私有的。<br>通过一个类来创建一个对象的过程称为 “实例化” 。</p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ol><li>公共 成员在类内可以访问 类外也可以访问</li><li>保护 成员在类内可以访问 类外不可以访问 父类的保护权限，子可以访问</li><li>私有 成员在类内可以访问 类外不可以访问 父类的私有权限，子也不可以访问 (继承)</li></ol><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><h4 id="使用构造函数来初始化，析构函数来清理。-构造函数和析构函数由编译器自动调用-但如果不自己实现，调用的是空实现。"><a href="#使用构造函数来初始化，析构函数来清理。-构造函数和析构函数由编译器自动调用-但如果不自己实现，调用的是空实现。" class="headerlink" title="使用构造函数来初始化，析构函数来清理。 构造函数和析构函数由编译器自动调用 但如果不自己实现，调用的是空实现。"></a>使用<code>构造函数</code>来初始化，<code>析构函数</code>来清理。 构造函数和析构函数由编译器自动调用 但如果不自己实现，调用的是空实现。</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>不需要写返回值类型，函数名称与类相同，可以有参数，可以发生重载。 <br><br>在创建对象时，程序会自动调用构造函数，不需要手动调用,并且只会调用一次</p><h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>没有返回值，没有参数，函数名前要加上<code>~</code><br><br>由于不可以有参数，所以不能发生重载。<br><br>和构造函数一样，析构函数会在对象销毁前自动调用析构函数。<br><br><strong>构造和析构函数都是必须要有的</strong> 如果自己不提供，程序会提供空实现</p><h3 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h3><p>按参数：有参构造和无参构造<br>按类型：普通构造和拷贝构造</p><h3 id="构造函数的调用方式"><a href="#构造函数的调用方式" class="headerlink" title="构造函数的调用方式"></a>构造函数的调用方式</h3><ol><li>括号法&emsp;&emsp;&emsp;<code>person p(10);</code></li><li>显示法&emsp;&emsp;&emsp;<code>person p = person(10);</code></li><li>隐式转换法&emsp;<code>person p = &#123;10,&quot;name&quot;&#125;;</code></li></ol><p><code>person(10)</code>创建的是一个匿名对象,匿名对象在当前行结束后就会被释放。显示法相当于给匿名对象找到一个名字。<br><br><strong>不要利用拷贝构造函数来初始化一个匿名的对象。</strong></p><h3 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h3><p>C++中拷贝构造函数的调用时机通常有三种情况</p><ul><li>使用一个已经创建完的对象来初始化一个新对象<code>person p(p0);</code></li><li>以值传递的方式给函数参数传参 <code>doWorK(p);</code> 值传递的本质会拷贝一个临时副本 这个过程会调用拷贝构造函数</li><li>以值方式返回局部对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person p1;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内的p1在函数运行完就会被是放掉,return 的p1是创建的新变量。</p><h3 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h3><p>C++会为一个类提供至少三个默认函数</p><ol><li>默认构造函数(空实现)</li><li>默认析构函数(空实现)</li><li>默认拷贝构造函数 &#x3D;&gt; 有默认内容(值拷贝)</li></ol><p><strong>如果你写了一个有参构造函数,C++不会提供默认无参构造，但会提供拷贝构造函数</strong><br><em><strong>如果你写了一个拷贝构造函数，C++就不会再提供默认的其他构造函数了</strong></em></p><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>深拷贝 重新申请空间<br><br>浅拷贝 直接赋值</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>传统操作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a_,<span class="type">int</span> b_,<span class="type">int</span> c_)</span><br><span class="line">&#123;</span><br><span class="line">    a = a_;</span><br><span class="line">    b = b_;</span><br><span class="line">    c = c_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>():<span class="built_in">a</span>(<span class="number">10</span>),<span class="built_in">b</span>(<span class="number">20</span>),<span class="built_in">c</span>(<span class="number">30</span>)&#123;&#125;  <span class="comment">//行参列表</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a_,<span class="type">int</span> b_,<span class="type">int</span> c_):<span class="built_in">a</span>(a_),<span class="built_in">b</span>(b_),<span class="built_in">c</span>(c_)&#123;&#125;  <span class="comment">//更灵活的写法</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br></pre></td></tr></table></figure><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当A作为B的成员时,创建一个类B的对象,会先创建一个类A的对象 &emsp; <strong>[先有手机后有人]</strong> </p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li>所有对象共享同一份数据</li><li>在编译阶段就分配内存 (还没有运行可执行文件前已经分好了)</li><li>类内声明，类外初始化 (必需操作) <strong>(static修饰的成员变量在类外初始化时分配内存)</strong> <strong>(静态成员并不具体作用在某个对象上)</strong></li><li>静态成员不能在类内初始化</li><li>C++中声明和定义是有区别的，在类内进行的是成员变量的声明，而不是定义。所以在类外初始化静态成员变量时仍然要加上数据类型。</li><li>由于静态成员变量不属于某个类，所以他有两种访问方式</li><li>1.通过对象访问</li><li>2.通过类名访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person::static_member_</span><br></pre></td></tr></table></figure><ul><li>静态成员变量也是有访问权限的 (类外访问不到静态成员变量的内容)</li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><p>成员函数的大小并不算在类里！成员变量和成员函数在存储上是分离的</p><p>静态成员变量的调用有两种访问方式</p><ol><li>通过对象 </li><li>通过类名</li></ol><p><strong>静态成员函数只能访问静态成员变量</strong></p><ul><li>静态成员函数也是有访问权限的</li></ul><h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><p>C++中 只有非静态成员变量才属于类的对象上</p><h4 id="空对象占用的内存大小为-1-字节"><a href="#空对象占用的内存大小为-1-字节" class="headerlink" title="空对象占用的内存大小为 1 字节"></a>空对象占用的内存大小为 1 字节</h4><p>C++编译器会给每个空对象也分配一个字节的空间，是为了区分每个对象占用的位置<br><br><em>不是存储对象的地址，而是把对象的地址占用住，防止别的对象存在同一地址</em></p><p><br><strong>在C++中,空结构体的大小也是 1</strong>&lt;br$$&gt;<br><strong>在C语言中 空结构体的大小是 0</strong></p><p>static成员变量和对象中的成员变量是分开存储的，不算在对象的大小里 (存储在全局区)</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h3><p>非静态成员函数的实例只有一份，它通过this指针来区分是哪个对象调用的自己。<br>用途</p><ul><li>当形参和成员变量同名时，可以用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可用 return *this<br>静态成员函数不具备 <code>this</code> 指针</li></ul><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++的空指针也是可以访问成员函数的<br>但是要判断this指针是否为空 加强代码的健壮性</p><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><h4 id="常函数"><a href="#常函数" class="headerlink" title="常函数:"></a>常函数:</h4><ul><li>成员函数后加 <code>const</code> 的函数叫做常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改</li></ul><h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象:"></a>常对象:</h4><ul><li>在声明对象时，在对象前面加<code>const</code> 来定义一个常对象</li><li>常对象只能调用常函数</li><li><code>mutable</code>在常对象下也适用</li></ul><p>在成员函数后加const修饰的其实是this指针，让指针指向的值也不可以修改</p><p><strong>常对象只能调用常函数的原理：常对象的<code>this</code>指针是常量指针，而<code>this</code>指针是作为<code>隐含参数</code>传给类内函数的，只有常函数的<code>this</code>指针是常量指针常量，可以接收常对象的<code>this</code>指针</strong> <em>(其实就是普通指针可以向const修饰的指针转换，而const修饰的指针不能向普通指针转换)</em></p><h3 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元 friend"></a>友元 <code>friend</code></h3><p>通过关键字<code>friend</code>可以让类外访问类内的私有属性 可以让一个函数或者类 访问另一个类中的私有成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Friend</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> Friend;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="title">Friend::func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p><strong>可以对已经存在的运算符进行重新定义，赋予另一种功能</strong></p><ol><li>加号运算符重载</li><li>左移运算符重载</li><li>递增运算符重载</li><li>赋值运算符重载 </li><li>关系运算符重载</li><li>函数调用运算符重载 (仿函数)<br>运算符可以以全局函数或成员函数的形式重载，拓展更多使用方法<br>cout是 ostream 类的一个对象 通过成员函数 operator<code>&lt;&lt;</code> 来输出内容<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_integer&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)  <span class="comment">//在()里写int以表明这是一个后置递增</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><em>继承可以减少重复的代码。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>      <span class="comment">// 父类 (基类)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">byBase</span> : <span class="keyword">public</span> Base  <span class="comment">// 子类 (派生类)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;func2()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类 <code>byBase</code> 会继承 类 <code>Base</code> 的函数 <code>func()</code> 从而拥有两个成员函数 <code>func()</code> 和 <code>func2()</code></p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。</span><br></pre></td></tr></table></figure><p><strong>使用共有继承方式，最大权限为公有</strong> </p><p><strong>使用保护继承方式，最大权限为保护</strong></p><p><strong>使用私有继承方式，最大权限为私有</strong></p><p>以私有方式继承，子类的子类什么都访问不到</p><h3 id="继承的对象模型"><a href="#继承的对象模型" class="headerlink" title="继承的对象模型"></a>继承的对象模型</h3><p>不管怎样继承，父类中的非静态成员属性都会被子类继承下去。</p><p>每个子类都会有一份继承自父类的成员</p><h3 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h3><p>当创建子类对象时，先有父类对象还是子类对象?</p><p>先构造 父类 ， 后构造 子类 。</p><p>析构的顺序和构造的顺序相反。</p><h3 id="继承中同名成员的处理方式"><a href="#继承中同名成员的处理方式" class="headerlink" title="继承中同名成员的处理方式"></a>继承中同名成员的处理方式</h3><p>在继承中遇到同名成员变量 需要在<code>.</code>后加父类的作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.Base::a = <span class="number">10</span>; <span class="comment">// 表示使用的是继承自父类的成员变量</span></span><br></pre></td></tr></table></figure><p>对于成员函数 同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.Base::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure><p>如果子类中出现了和父类中同名的成员函数，那么子类会将父类中的所有成员函数隐藏掉，<strong>包括重载的函数</strong><br>必须加作用域才可以访问。</p><h3 id="继承中静态成员变量的处理方式"><a href="#继承中静态成员变量的处理方式" class="headerlink" title="继承中静态成员变量的处理方式"></a>继承中静态成员变量的处理方式</h3><p>静态成员变量可以通过类名访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过子类访问父类继承的静态成员变量</span></span><br><span class="line">Son::Base::m_A;</span><br></pre></td></tr></table></figure><h3 id="C-多继承"><a href="#C-多继承" class="headerlink" title="C++多继承"></a>C++多继承</h3><p>C++允许一个类继承多个类</p><p>当父类中出现同名成员 需要加作用域区分</p><p><strong>在开发中不建议采用多继承写法</strong></p><h3 id="菱形继承-virtual"><a href="#菱形继承-virtual" class="headerlink" title="菱形继承 (virtual)"></a>菱形继承 (virtual)</h3><p>两个派生类继承同一个基类，又被同一个派生类继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">C     D</span><br><span class="line"> \   /</span><br><span class="line">   E</span><br></pre></td></tr></table></figure><p>E通过C，D继承A的成员时，只需要一份，却继承了两份，造成资源浪费</p><p>此时可以通过<code>虚继承</code>实现</p><p>继承时加上<code>virtual</code> 后，继承方式变为虚继承 , 数据只存一份</p><p>并且虚继承默认访问的是第一个基类 </p><p>虚继承的派生类中存的是<code>vbptr</code> <strong>『虚基类指针』</strong> 指向 <code>vbtable</code> <strong>『虚基类表』</strong> 记录了派生类成员相对基类成员的偏移量</p><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><h3 id="静态多态和动态多态"><a href="#静态多态和动态多态" class="headerlink" title="静态多态和动态多态"></a>静态多态和动态多态</h3><p>静态多态：函数重载和运算符重载</p><p>动态多态：派生类和虚函数来实现动态多态</p><p>区别:</p><ul><li>静态多态的函数地址早绑定 &#x3D;&gt; 在编译阶段就确定了函数的地址</li><li>动态多态的函数地址晚绑定 &#x3D;&gt; 程序运行时才能确定函数地址</li></ul><p>C++允许父类的引用指向一个子类对象 不需要进行类型转换</p><p>通过在基类的函数前加入关键字<code>virtual</code>，可以实现地址晚绑定，使一个函数表现出不同的效果</p><p>动态多态的条件：</p><ol><li>有基础关系</li><li>子类要重写父类的虚函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写:函数的返回值，形参和函数名都要相同</span><br><span class="line">重载:根据形参的不同区分两个函数</span><br></pre></td></tr></table></figure><p>动态多态的使用: 要用父类的指针或引用指向子类的对象 调用虚函数</p><h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><p>有虚函数的基类中会存一个被称为<code>vfptr</code>的指针 即<code>虚函数指针</code> (aka虚函数表指针)<br>它会指向一个虚函数表<code>vftable</code> 该表内部会记录一个虚函数的地址 </p><p>子类会继承父类的<code>vfptr</code>指向自己的虚函数表 父类和子类不会共享一个虚函数表</p><p>类的对象的隐藏成员保存的类的虚函数指针(vfptr)，指向类的虚函数表 虚函数表是一个顺序表 表中有许多槽(slot),每个槽中存放的是一个虚函数的指针(地址) </p><p>如果派生类重写了基类的虚函数，派生虚函数表将基类虚函数的地址替换为派生类虚函数的地址，<br>如果派生类中没有重写虚函数，派生虚函数表将保存基类虚函数的地址。如果派生类中还定义了虚函数，那么该虚函数的地址也会被添加到虚派生类表里去。</p><p>为了保证虚函数表的性能，C++会保证虚函数表的指针存在于对象实例的最前面的位置。</p><p>当父类的指针或者引用指向子类对象时，就会发生<code>多态</code></p><p>在创建派生类的对象时，虚函数指针会被指向派生类虚函数表。</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>多态中父类的虚函数大多没什么用,可以将虚函数改为纯虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义一个纯虚函数 </span></span><br></pre></td></tr></table></figure><p>只要类中有一个纯虚函数，类就会成为<code>抽象类</code> 无法实例化一个对象</p><p>抽象类的子类必须重写抽象类的纯虚函数，否则该子类也属于抽象类，无法实例化对象</p><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，父类的指针无法释放子类中的析构代码，所以子类数据无法释放，会造成内存泄漏。</p><p>此时需要利用<code>虚析构</code>和<code>纯虚析构</code> 虚析构和纯虚析构都需要函数的实现</p><p>如果类中有了纯虚析构，该类也会属于抽象类</p><p>只要在父类的析构函数前加上<code>virtual</code> 即可调用子类的析构函数</p><p>纯虚析构也能有这个效果,但是纯虚析构必须在类外实现函数体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 实现 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型和STL"><a href="#泛型和STL" class="headerlink" title="泛型和STL"></a>泛型和STL</h1><p>C++支持<code>泛型编程</code> 和 <code>STL</code></p><p><code>泛型编程</code>主要靠<code>模板</code>实现,可大大提高复用性。   </p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ol><li>模板不可以直接使用，它只是一个框架。</li><li>模板的通用并不是万能的。</li></ol><h3 id="模板的语法"><a href="#模板的语法" class="headerlink" title="模板的语法"></a>模板的语法</h3><ul><li>函数模板</li><li>类模板</li></ul><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>语法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 函数声明或定义</span></span><br></pre></td></tr></table></figure><p>写模板时可以先不指定返回值和形参是什么数据类型 使用的时候再确定数据类型</p><p>template: 声明创建模板<br>typename: 表明T是数据类型的名称 可以用class替代<br>T 是可以替换的数据类型 (自定义)</p><p>***36_STL</p><hr><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><code>STL</code> 即 <code>Standard Template Library</code> 标准模板库</p><p>STL 从广义上分为 <strong><code>容器(container)</code></strong> <strong><code>算法(algorithm)</code></strong> <strong><code>迭代器(iterator)</code></strong> </p><p>迭代器连接了容器与算法</p><p>STL中的所有类基本上都使用了模板类和模板函数</p><p>STL的六大组件 – 容器、算法、迭代器、仿函数、适配器、空间配置器</p><ol><li>容器 是各种数据结构 用来存储数据</li><li>算法 各种常用的算法 (sort,find,copy,for_each)</li><li>迭代器 迭代器 交流容器和算法</li><li>仿函数 函数调用运算符的重载</li><li>适配器 用来修饰容器或者仿函数或迭代器接口</li><li>空间配置器 负责空间的配置和管理</li></ol><p><strong>容器</strong>分为序列式容器和关联式容器</p><p>序列式容器强调值的排序，每个元素都有固定的位置</p><p>关联式容器各元素之间没有严格的物理上的顺序关系</p><p><strong>算法</strong>分为质变算法和非质变算法</p><p>质变算法在运行期间会更改元素的内容     (增，删，改)</p><p>非质变算法在运行期间不会改变元素的内容 (查找，计数)</p><p>算法要通过迭代器才能访问容器里的元素 每种容器都有自己专属的迭代器</p><p>迭代器非常类似于指针</p><p>迭代器的种类: 输入、输出、向前、双向、随机访问</p><p><code>输入迭代器</code>对数据进行只读访问</p><p><code>输出迭代器</code>对数据进行只写访问</p><p><code>前向迭代器</code>可以向前推进，并且可以进行读写操作</p><p>**<code>双向迭代器</code>**可以进行读写操作，并且可以向前和向后操作</p><p>**<code>随机访问迭代器</code>**支持读写操作，并且可以以跳跃的方式访问任意数据</p><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><p>vector容器可以理解为一个数组。</p><h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><p>封装了C语言的字符串</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPP-LEARNING&quot;&gt;&lt;a href=&quot;#CPP-LEARNING&quot; class=&quot;headerlink&quot; title=&quot;CPP LEARNING&quot;&gt;&lt;/a&gt;CPP LEARNING&lt;/h1&gt;&lt;h2 id=&quot;1-new&quot;&gt;&lt;a href=&quot;#1-new&quot; c</summary>
      
    
    
    
    
    <category term="C++" scheme="http://aetherance.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>INK_SuperShell实现</title>
    <link href="http://aetherance.github.io/2024/12/29/INK-super-shell%E5%AE%9E%E7%8E%B0/"/>
    <id>http://aetherance.github.io/2024/12/29/INK-super-shell%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-29T08:05:11.000Z</published>
    <updated>2025-01-08T14:41:20.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TASK"><a href="#TASK" class="headerlink" title="TASK"></a>TASK</h2><p>打造一个绝无伦比的 xxx-super-shell (xxx 是你的名字)，它能实现下面这些功能：</p><ul><li>实现管道（也就是 |）</li><li>实现输入输出重定向（也就是 &lt; &gt; &gt;&gt;）</li><li>要求在管道组合命令的两端实现重定向运算符</li></ul><p><a href="https://plan.xiyoulinux.com/project/shell/">PLAN</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 需要实现的功能</span><br><span class="line">cat &lt; <span class="number">1.</span>txt | grep -C <span class="number">10</span> abc | grep -Lefd | tac &gt;&gt; <span class="number">2.</span>txt</span><br><span class="line"># 不需要实现的功能</span><br><span class="line">cat &lt; <span class="number">1.</span>txt | grep -C <span class="number">10</span> abc &gt; test1.txt | test2.txt &gt; grep -L efd | tac &gt;&gt; <span class="number">2.</span>txt</span><br></pre></td></tr></table></figure><ul><li>实现后台运行（也就是 &amp;）</li><li>实现 cd，要求支持能切换到绝对路径、相对路径和支持 cd -</li><li>屏蔽一些信号（如 ctrl + c 不能终止）</li><li>界面美观</li><li>开发过程记录、总结、发布在个人博客中<br>要求：</li><li>不得出现内存泄漏、内存越界等错误 - 学会如何使用 gdb 进行调试，使用 valgrind 等工具进行检测</li></ul><h3 id="ish-cpp"><a href="#ish-cpp" class="headerlink" title="ish.cpp"></a>ish.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;shell.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DB 1    <span class="comment">// DB为1时,进入debug模式 不屏蔽信号</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ish sh;</span><br><span class="line">    Prompt pr;</span><br><span class="line">    Command cmd;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">if</span>(!DB)<span class="built_in">nosignal</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;clear&quot;</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pr.<span class="built_in">PrintPrompt</span>();</span><br><span class="line">        sh.<span class="built_in">GetCommand</span>();</span><br><span class="line">        cmd.<span class="built_in">Process</span>();</span><br><span class="line">        sh.<span class="built_in">LineClear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shell-hpp"><a href="#shell-hpp" class="headerlink" title="shell.hpp"></a>shell.hpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nosignal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string,<span class="type">char</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">char</span>*&gt;<span class="built_in">fromStoC</span>(vector&lt;string&gt;);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRedirect</span><span class="params">(string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ish</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> vector&lt;string&gt;<span class="built_in">split</span>(string,<span class="type">char</span>);</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">bool</span> <span class="title">isRedirect</span><span class="params">(string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetCommand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LineClear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">iscd</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ish</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> path[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">realpath</span>(<span class="string">&quot;.&quot;</span>,path);</span><br><span class="line">        wdPath = path;</span><br><span class="line">        <span class="built_in">setenv</span>(<span class="string">&quot;OWD&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">char</span> hostname[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">gethostname</span>(hostname,<span class="number">64</span>);</span><br><span class="line">        hostName = hostname;</span><br><span class="line">        <span class="type">int</span> userid = <span class="built_in">getuid</span>();</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">passwd</span> * pwd = <span class="built_in">getpwuid</span>(userid);</span><br><span class="line">        userName = pwd-&gt;pw_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string hostName;</span><br><span class="line">    string userName;</span><br><span class="line">    string gitHEAD = <span class="string">&quot;master&quot;</span>;</span><br><span class="line">    <span class="type">static</span> string wdPath;</span><br><span class="line">    <span class="type">static</span> string line;</span><br><span class="line">    <span class="type">static</span> vector&lt;string&gt;argv;</span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">int</span> *&gt;fds;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ExeCount;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> pipeError;</span><br><span class="line">    <span class="type">int</span> PromptLen;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isError;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prompt</span>: <span class="keyword">public</span> ish</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPrompt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">Prompt</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        failed = <span class="string">&quot;\e[100m\e[31m ✘\e[39m&quot;</span>;</span><br><span class="line">        isError = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string colors;</span><br><span class="line">    string output;</span><br><span class="line">    string failed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>: <span class="keyword">public</span> Prompt</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isClear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">isExit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExeCommand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="using-cpp"><a href="#using-cpp" class="headerlink" title="using.cpp"></a>using.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;shell.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string showName[<span class="number">9</span>];</span><br><span class="line">    showName[<span class="number">0</span>] = <span class="string">&quot;      __                                               __         &quot;</span>;</span><br><span class="line">    showName[<span class="number">1</span>] = <span class="string">&quot;     /\\ \\                                  __         /\\ \\        &quot;</span>;</span><br><span class="line">    showName[<span class="number">2</span>] = <span class="string">&quot;  ___\\ \\ \\___         ___ ___   __  __    /\\_\\    ____\\ \\ \\___    &quot;</span>;</span><br><span class="line">    showName[<span class="number">3</span>] = <span class="string">&quot; / __`\\ \\  _ `\\     /&#x27; __` __`\\/\\ \\/\\ \\   \\/\\ \\  /&#x27;,__\\ \\  _ `\\  &quot;</span>;</span><br><span class="line">    showName[<span class="number">4</span>] = <span class="string">&quot;/\\ \\L\\ \\ \\ \\ \\ \\    /\\ \\/\\ \\/\\ \\ \\ \\_\\ \\   \\ \\ \\/\\__, `\\ \\ \\ \\ \\ &quot;</span>;</span><br><span class="line">    showName[<span class="number">5</span>] = <span class="string">&quot;\\ \\____/\\ \\_\\ \\_\\   \\ \\_\\ \\_\\ \\_\\/`____ \\   \\ \\_\\/\\____/ \\ \\_\\ \\_\\&quot;</span>;</span><br><span class="line">    showName[<span class="number">6</span>] = <span class="string">&quot; \\/___/  \\/_/\\/_/    \\/_/\\/_/\\/_/`/___/&gt; \\   \\/_/\\/___/   \\/_/\\/_/&quot;</span>;</span><br><span class="line">    showName[<span class="number">7</span>] = <span class="string">&quot;                                    /\\___/                        &quot;</span>;</span><br><span class="line">    showName[<span class="number">8</span>] = <span class="string">&quot;                                    \\/__/                         &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\e[9%dm&quot;</span>,i);</span><br><span class="line">        cout&lt;&lt;showName[i]&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">110000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入 &#x27;?&#x27; 以获取帮助&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请按任意键继续&quot;</span>;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string ish::wdPath;</span><br><span class="line">string ish::line;</span><br><span class="line">vector&lt;string&gt; ish::argv;</span><br><span class="line"><span class="type">bool</span> ish::isError = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> ish::ExeCount = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span> *&gt; ish::fds;</span><br><span class="line"><span class="type">bool</span> ish::pipeError = <span class="literal">false</span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string s,<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt;result;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[pos]==ch)</span><br><span class="line">        pos++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pos&lt; s.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[pos+n]!=ch&amp;&amp;pos+n&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(pos,n));</span><br><span class="line">        pos += n;</span><br><span class="line">        <span class="keyword">while</span> (s[pos] ==ch&amp;&amp;pos&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span> *&gt; <span class="title">fromStoC</span><span class="params">(vector&lt;string&gt;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span> *&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buf = <span class="keyword">new</span> <span class="type">char</span>[s[i].<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,s[i].<span class="built_in">c_str</span>());</span><br><span class="line">        c.<span class="built_in">push_back</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nosignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT,SIG_IGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRedirect</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&#x27;&lt;&#x27;</span>)==<span class="number">-1</span>&amp;&amp;str.<span class="built_in">find</span>(<span class="string">&#x27;&gt;&#x27;</span>)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prompt::PrintPrompt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    output = <span class="string">&quot;\e[100m&quot;</span> + (string)<span class="string">&quot; &quot;</span> + userName + <span class="string">&quot;@&quot;</span> + hostName + <span class="string">&quot; &quot;</span> + (string)<span class="string">&quot;\e[90m&quot;</span> + (string)<span class="string">&quot;\e[104m&quot;</span> + <span class="string">&quot;&quot;</span> + <span class="string">&quot; &quot;</span> + wdPath + <span class="string">&quot; &quot;</span> + <span class="string">&quot;\e[43m&quot;</span> + <span class="string">&quot;\e[34m&quot;</span> + <span class="string">&quot;&quot;</span> + <span class="string">&quot;\e[33m&quot;</span> + <span class="string">&quot;  &quot;</span> + gitHEAD + <span class="string">&quot; ± &quot;</span> + <span class="string">&quot;\e[33m&quot;</span> + <span class="string">&quot;\e[49m&quot;</span> + <span class="string">&quot;&quot;</span> + <span class="string">&quot;\e[39m\e[0m&quot;</span>;</span><br><span class="line">    isError ? (cout&lt;&lt; failed + output &lt;&lt; <span class="string">&quot; &quot;</span>) : cout &lt;&lt; output &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    isError = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ish::GetCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FLAG:</span><br><span class="line">    <span class="built_in">getline</span>(cin,line);  <span class="comment">// get a line of command</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (line[pos] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos ++;</span><br><span class="line">    &#125;</span><br><span class="line">    line = line.<span class="built_in">substr</span>(pos);</span><br><span class="line">    argv = <span class="built_in">split</span>(line,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(line.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Prompt news;</span><br><span class="line">        news.<span class="built_in">PrintPrompt</span>();</span><br><span class="line">        <span class="keyword">goto</span> FLAG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ish::LineClear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    line.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Command::isClear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(line == <span class="string">&quot;clear&quot;</span>||line == <span class="string">&quot;cls&quot;</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::isExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(line == <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isH</span><span class="params">(string line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(line==<span class="string">&quot;?&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">help</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(line==<span class="string">&quot;!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">show</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::Process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isH</span>(line))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span> *&gt;vpipes;</span><br><span class="line">    vector&lt;string&gt;v = <span class="built_in">split</span>(line,<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(v.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv = <span class="built_in">split</span>(v[<span class="number">0</span>],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">ExeCommand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;ish: | 解析错误&quot;</span>&lt;&lt;endl;</span><br><span class="line">            isError = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;v.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> * fd = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">pipe</span>(fd);</span><br><span class="line">            fds.<span class="built_in">push_back</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            argv = <span class="built_in">split</span>(v[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="built_in">ExeCommand</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ExeCount != <span class="number">0</span>)<span class="built_in">close</span>(fds[ExeCount<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(ExeCount != fds.<span class="built_in">size</span>())<span class="built_in">close</span>(fds[ExeCount][<span class="number">1</span>]);    </span><br><span class="line"></span><br><span class="line">            ExeCount ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ExeCount = <span class="number">0</span>;</span><br><span class="line">        fds.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::ExeCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span> *&gt;ar = <span class="built_in">fromStoC</span>(argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isClear</span>()||<span class="built_in">iscd</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">isExit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ExeCount != <span class="number">0</span>)<span class="built_in">dup2</span>(fds[ExeCount<span class="number">-1</span>][<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ExeCount != fds.<span class="built_in">size</span>())<span class="built_in">dup2</span>(fds[ExeCount][<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isRedirect</span>(line))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(argv.<span class="built_in">size</span>()&lt;<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;ish: 重定向 解析错误&quot;</span>&lt;&lt;endl;</span><br><span class="line">                isError = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;argv.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(argv[i]==<span class="string">&quot;&lt;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[i<span class="number">+1</span>].<span class="built_in">data</span>(),O_RDONLY);</span><br><span class="line">                    <span class="built_in">dup2</span>(fd,<span class="number">0</span>);</span><br><span class="line">                    ar.<span class="built_in">erase</span>(ar.<span class="built_in">begin</span>()+i);</span><br><span class="line">                    <span class="built_in">close</span>(fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(argv[i]==<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[i<span class="number">+1</span>].<span class="built_in">data</span>(),O_RDWR|O_CREAT|O_TRUNC,S_IRUSR|S_IWUSR);</span><br><span class="line">                    <span class="built_in">dup2</span>(fd,<span class="number">1</span>);</span><br><span class="line">                    ar.<span class="built_in">erase</span>(ar.<span class="built_in">begin</span>()+i);</span><br><span class="line">                    ar.<span class="built_in">erase</span>(ar.<span class="built_in">begin</span>()+i<span class="number">+1</span>);</span><br><span class="line">                    <span class="built_in">close</span>(fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(argv[i]==<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[i<span class="number">+1</span>].<span class="built_in">data</span>(),O_RDWR|O_APPEND|O_CREAT,S_IRUSR|S_IWUSR);</span><br><span class="line">                    <span class="built_in">dup2</span>(fd,<span class="number">1</span>);</span><br><span class="line">                    ar.<span class="built_in">erase</span>(ar.<span class="built_in">begin</span>()+i);</span><br><span class="line">                    ar.<span class="built_in">erase</span>(ar.<span class="built_in">begin</span>()+i<span class="number">+1</span>);</span><br><span class="line">                    <span class="built_in">close</span>(fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ar.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(ar[<span class="number">0</span>],<span class="string">&quot;ls&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ar.<span class="built_in">pop_back</span>();</span><br><span class="line">            ar.<span class="built_in">push_back</span>((<span class="type">char</span> *)<span class="string">&quot;--color=auto&quot;</span>);</span><br><span class="line">            ar.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">execvp</span>(ar[<span class="number">0</span>],ar.<span class="built_in">data</span>())==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isError = <span class="literal">true</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;ish: command not found: &quot;</span>&lt;&lt;argv[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wait</span>(&amp;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ish::iscd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]!=<span class="string">&quot;cd&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> * homepath = <span class="built_in">getenv</span>(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="string">&quot;cd&quot;</span>&amp;&amp;argv.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">        argv.<span class="built_in">push_back</span>(homepath);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * lpath = <span class="built_in">getenv</span>(<span class="string">&quot;OWD&quot;</span>);</span><br><span class="line">        cout&lt;&lt;lpath&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chdir</span>(lpath)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wdPath = lpath;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> rp[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">realpath</span>(argv[<span class="number">1</span>].<span class="built_in">c_str</span>(),rp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chdir</span>(argv[<span class="number">1</span>].<span class="built_in">c_str</span>())==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;cd: path not found&quot;</span>&lt;&lt;endl;</span><br><span class="line">        isError = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;OWD&quot;</span>,wdPath.<span class="built_in">c_str</span>(),<span class="number">1</span>);</span><br><span class="line">    wdPath = rp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;你知道吗？输入!可以观看炫酷的动画。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TASK&quot;&gt;&lt;a href=&quot;#TASK&quot; class=&quot;headerlink&quot; title=&quot;TASK&quot;&gt;&lt;/a&gt;TASK&lt;/h2&gt;&lt;p&gt;打造一个绝无伦比的 xxx-super-shell (xxx 是你的名字)，它能实现下面这些功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Linux系统编程 Linux进程通信" scheme="http://aetherance.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>ls实现</title>
    <link href="http://aetherance.github.io/2024/12/29/ls/"/>
    <id>http://aetherance.github.io/2024/12/29/ls/</id>
    <published>2024-12-29T07:13:44.000Z</published>
    <updated>2025-01-08T14:41:20.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现自己的-ls-命令"><a href="#实现自己的-ls-命令" class="headerlink" title="实现自己的 ls 命令"></a>实现自己的 ls 命令</h2><p><a href="https://plan.xiyoulinux.com/project/ls/">PLAN</a></p><h3 id="任务说明"><a href="#任务说明" class="headerlink" title="任务说明"></a>任务说明</h3><p><code>ls</code> 是 GNU&#x2F;Linux 操作系统中常见的命令。 请使用 C 语言，基于 GNU&#x2F;Linux 操作系统，编程实现 ls 命令的部分功能。</p><h3 id="验收要求"><a href="#验收要求" class="headerlink" title="验收要求"></a>验收要求</h3><ul><li>实现 ls 的 -a、-l、-R、-t、-r、-i、-s 参数，并允许这些参数任意组合。</li><li>-R 需要对 &#x2F; 的遍历测试。</li><li>界面美观（输出对齐、带颜色显示等）。</li><li>无资源与内存泄漏。</li><li>开发过程记录、总结并发布在个人博客中。</li></ul><p>CODE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_SIZE 20970</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH_SIZE 4048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH_SIZE 2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_COUNT_MAX 25600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Rsize 40000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT__A <span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT__L <span class="string">&#x27;l&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT__T <span class="string">&#x27;t&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT__R <span class="string">&#x27;r&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT_RR <span class="string">&#x27;R&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT__I <span class="string">&#x27;i&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPT__S <span class="string">&#x27;s&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*FP)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ifm</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">rdirent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf__stat</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> opt_count_sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> opt;    <span class="comment">// temp</span></span><br><span class="line"><span class="type">char</span> optTable[<span class="number">256</span>] = &#123;&#125;;  <span class="comment">// 01 table</span></span><br><span class="line"><span class="type">char</span> **filepath;</span><br><span class="line"><span class="type">int</span> FileNameCount = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> FileNameRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="type">int</span> order = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">R</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sort_init</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sort_by_change_time</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(<span class="keyword">struct</span> ifm * readifm)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintWithL</span><span class="params">(<span class="keyword">struct</span> ifm *readifm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    filepath = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="number">80</span>);</span><br><span class="line">    filepath[<span class="number">0</span>] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(filepath[<span class="number">0</span>],<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getopt</span></span><br><span class="line">    <span class="keyword">while</span>((opt = getopt(argc,argv,<span class="string">&quot;alRtris&quot;</span>))!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        optTable[opt] = <span class="number">1</span>;</span><br><span class="line">        opt_count_sum += optTable[opt];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ** arcu = argv+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*arcu!=<span class="literal">NULL</span>&amp;&amp;arcu&lt;argv+argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(**arcu != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FileNameCount--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arcu ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arcu = argv+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*arcu!=<span class="literal">NULL</span>&amp;&amp;arcu&lt;argv+argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(**arcu != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            filepath[FileNameCount] = (<span class="type">char</span> *)<span class="built_in">realloc</span>(filepath[FileNameCount],(<span class="built_in">strlen</span>(*arcu)+<span class="number">1</span>)* <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            <span class="built_in">strcpy</span>(filepath[FileNameCount++],*arcu);</span><br><span class="line">        &#125;</span><br><span class="line">        arcu++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    order = optTable[OPT__R] ? <span class="number">-1</span> : <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(optTable[OPT_RR])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;FileNameCount;i++)</span><br><span class="line">            R(filepath[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;FileNameCount;i++)</span><br><span class="line">            <span class="built_in">free</span>(filepath[i]);</span><br><span class="line">        <span class="built_in">free</span>(filepath);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (FileNameRead&lt;FileNameCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// open</span></span><br><span class="line">        DIR * dir = opendir(filepath[FileNameRead]);</span><br><span class="line">        <span class="keyword">if</span>(dir!=<span class="literal">NULL</span>&amp;&amp;FileNameCount&gt;<span class="number">1</span>||optTable[OPT_RR])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>,filepath[FileNameRead]);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">rdirent</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf__stat</span>;</span>    <span class="comment">// 静态开辟空间</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> * <span class="title">statbuf</span> =</span> &amp;buf__stat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT_RR])</span><br><span class="line">            &#123;</span><br><span class="line">                FileNameRead ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: 无法访问 &#x27;%s&#x27;: 没有那个文件或目录\n&quot;</span>,filepath[FileNameRead]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifm</span> * <span class="title">ifmlist</span> =</span> (<span class="keyword">struct</span> ifm *)<span class="built_in">malloc</span>(<span class="number">2048</span>*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ifm));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifm</span> * <span class="title">cur</span> =</span> ifmlist;</span><br><span class="line">        <span class="type">int</span> all_name_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total_name_len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp_line_len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">0</span>;     <span class="comment">//最长文件名</span></span><br><span class="line">        <span class="type">int</span> line_print_now = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> divide_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> blockSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fileSizeLenMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">temp_dirent</span>;</span></span><br><span class="line">        <span class="comment">// 读目录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((temp_dirent = readdir(dir))!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;rdirent = * temp_dirent;</span><br><span class="line">            <span class="comment">// get_max_len</span></span><br><span class="line">            <span class="comment">//printf(&quot;Ptr&#x27;s addr: %p %p\n&quot;,(void*)cur, (void*)&amp;ifmlist[testcount]);</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(cur-&gt;rdirent.d_name)&gt;max_len)</span><br><span class="line">                max_len = <span class="built_in">strlen</span>(cur-&gt;rdirent.d_name)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//max_len = max_len&gt;7?7:max_len;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> path[PATH_SIZE];</span><br><span class="line">            <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,filepath[FileNameRead],cur-&gt;rdirent.d_name);</span><br><span class="line">            stat(path,&amp;cur-&gt;buf__stat);</span><br><span class="line"></span><br><span class="line">            total_name_len += <span class="built_in">strlen</span>(cur-&gt;rdirent.d_name) + <span class="number">2</span>; <span class="comment">// 确定总长度 判断是否需要切换输出模式</span></span><br><span class="line">            <span class="comment">//total_name_len-=2;  // 减去最后的两个空格</span></span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT__S]) total_name_len += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT__I]) total_name_len += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT__A])blockSum += cur-&gt;buf__stat.st_blocks/<span class="number">2</span>; <span class="comment">// why</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((cur-&gt;rdirent.d_name)[<span class="number">0</span>]!=<span class="string">&#x27;.&#x27;</span>)blockSum += cur-&gt;buf__stat.st_blocks/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> temp = cur-&gt;buf__stat.st_size;</span><br><span class="line">            <span class="type">int</span> fileSizeLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp)</span><br><span class="line">                temp/=<span class="number">10</span>,fileSizeLen ++;</span><br><span class="line">            <span class="keyword">if</span>(fileSizeLen&gt;fileSizeLenMax)</span><br><span class="line">                fileSizeLenMax = fileSizeLen;</span><br><span class="line">            </span><br><span class="line">            all_name_count++;</span><br><span class="line">            cur++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get_sort_mode</span></span><br><span class="line">        FP sort_mode = sort_init;</span><br><span class="line">        <span class="keyword">if</span>(optTable[OPT__T])sort_mode = sort_by_change_time;</span><br><span class="line">        qsort(ifmlist,all_name_count,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ifm),sort_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get_print_format</span></span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">win</span>;</span></span><br><span class="line">        ioctl(STDIN_FILENO,TIOCGWINSZ,&amp;win);</span><br><span class="line">        divide_count = total_name_len / win.ws_col + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// opt_s using</span></span><br><span class="line">        <span class="keyword">if</span>(optTable[OPT__L]||optTable[OPT__S])<span class="built_in">printf</span>(<span class="string">&quot;总计 %zu\n&quot;</span>,blockSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read from ifm</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifm</span> * <span class="title">readifm</span> =</span> ifmlist;</span><br><span class="line">        <span class="keyword">while</span>(readifm!=cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!optTable[OPT__A])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(readifm-&gt;rdirent.d_name,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(readifm-&gt;rdirent.d_name,<span class="string">&quot;..&quot;</span>)||*readifm-&gt;rdirent.d_name==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                readifm++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出格式</span></span><br><span class="line">            <span class="keyword">if</span>(!optTable[OPT__L]&amp;&amp;line_print_now == ((all_name_count/divide_count<span class="number">-1</span>))/(optTable[OPT_RR]?<span class="number">2</span>:<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b\b&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                temp_line_len = <span class="number">0</span>;</span><br><span class="line">                line_print_now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT__I])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lu &quot;</span>,readifm-&gt;rdirent.d_ino);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT__S])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2lu &quot;</span>,readifm-&gt;buf__stat.st_blocks/<span class="number">2</span>);     <span class="comment">// why</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(optTable[OPT__L])    <span class="comment">// -l</span></span><br><span class="line">            &#123;</span><br><span class="line">                PrintWithL(readifm);</span><br><span class="line">                PrintList(readifm);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!optTable[OPT_RR]&amp;&amp;total_name_len&lt;=win.ws_col)</span><br><span class="line">            &#123;</span><br><span class="line">                PrintList(readifm);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp_line_len += <span class="built_in">strlen</span>(readifm-&gt;rdirent.d_name)+<span class="number">2</span>;</span><br><span class="line">                temp_line_len += <span class="built_in">strlen</span>(readifm-&gt;rdirent.d_name)+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(S_ISREG(readifm-&gt;buf__stat.st_mode)</span><br><span class="line">                &amp;&amp;!(readifm-&gt;buf__stat.st_mode &amp; S_IXUSR))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%-*s&quot;</span>,max_len,readifm-&gt;rdirent.d_name);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(S_ISREG(readifm-&gt;buf__stat.st_mode)</span><br><span class="line">                &amp;&amp;(readifm-&gt;buf__stat.st_mode &amp; S_IXUSR))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;32m%-*s\033[0m&quot;</span>,max_len,readifm-&gt;rdirent.d_name);   <span class="comment">// 可执行文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(S_ISDIR(readifm-&gt;buf__stat.st_mode))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m&quot;</span><span class="string">&quot;%-*s\033[0m&quot;</span>,max_len,readifm-&gt;rdirent.d_name);</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            line_print_now ++;</span><br><span class="line">            readifm ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!optTable[OPT__L])<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        FileNameRead ++;</span><br><span class="line">        <span class="keyword">if</span>(FileNameCount&gt;<span class="number">1</span>&amp;&amp;FileNameCount!=FileNameRead)<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(ifmlist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;FileNameCount;i++)</span><br><span class="line">        <span class="built_in">free</span>(filepath[i]);</span><br><span class="line">    <span class="built_in">free</span>(filepath);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">R</span><span class="params">(<span class="type">char</span> * Rfile)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifm</span> * <span class="title">Rlist</span> =</span> (<span class="keyword">struct</span> ifm *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ifm) * Rsize);</span><br><span class="line"></span><br><span class="line">    DIR * rdir = opendir(Rfile);</span><br><span class="line">    <span class="keyword">if</span>(rdir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\033[0m&quot;</span><span class="string">&quot;ls: 无法打开目录 &#x27;%s&#x27;: 权限不够\n&quot;</span>,Rfile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">int</span> count4q = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">trdir</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;(trdir = readdir(rdir))!=<span class="literal">NULL</span>;i++,count4q++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> temp[<span class="number">2000</span>];</span><br><span class="line">        Rlist[i].rdirent = *trdir;</span><br><span class="line">        <span class="built_in">sprintf</span>(temp,<span class="string">&quot;%s/%s&quot;</span>,Rfile,Rlist[i].rdirent.d_name);</span><br><span class="line">        stat(temp,&amp;Rlist[i].buf__stat);</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(Rlist,count4q,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ifm),sort_init);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:\n\n&quot;</span>,Rfile);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;count4q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!optTable[OPT__A])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*Rlist[i].rdirent.d_name==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(optTable[OPT__I])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lu &quot;</span>,Rlist[i].rdirent.d_ino);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(optTable[OPT__S])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2lu &quot;</span>,Rlist[i].buf__stat.st_blocks/<span class="number">2</span>);     <span class="comment">// why</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(optTable[OPT__L])</span><br><span class="line">        &#123;</span><br><span class="line">            PrintWithL(&amp;Rlist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S_ISDIR(Rlist[i].buf__stat.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[1;5;34m&quot;</span><span class="string">&quot;%s\n\033[0m&quot;</span>,Rlist[i].rdirent.d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(Rlist[i].rdirent.d_name,<span class="string">&quot;.png&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[1;5;35m&quot;</span><span class="string">&quot;%s\n\033[0m&quot;</span>,Rlist[i].rdirent.d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rlist[i].buf__stat.st_mode&amp;S_IXUSR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[1;5;32m&quot;</span><span class="string">&quot;%s\n\033[0m&quot;</span>,Rlist[i].rdirent.d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(Rlist[i].rdirent.d_name,<span class="string">&quot;.tar&quot;</span>)!=<span class="literal">NULL</span>||<span class="built_in">strstr</span>(Rlist[i].rdirent.d_name,<span class="string">&quot;.gz&quot;</span>)!=<span class="literal">NULL</span>||<span class="built_in">strstr</span>(Rlist[i].rdirent.d_name,<span class="string">&quot;.zip&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[1;5;31m&quot;</span><span class="string">&quot;%s\n\033[0m&quot;</span>,Rlist[i].rdirent.d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,Rlist[i].rdirent.d_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;count4q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S_ISDIR(Rlist[i].buf__stat.st_mode)&amp;&amp;<span class="built_in">strcmp</span>(Rlist[i].rdirent.d_name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(Rlist[i].rdirent.d_name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> go[<span class="number">1000</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(go,<span class="string">&quot;%s/%s&quot;</span>,Rfile,Rlist[i].rdirent.d_name);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">ng</span>;</span></span><br><span class="line">            </span><br><span class="line">            lstat(go,&amp;ng);</span><br><span class="line">            <span class="keyword">if</span>(ng.st_mode==<span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(S_ISLNK(ng.st_mode))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!optTable[OPT__A])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(*Rlist[i].rdirent.d_name==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            R(go);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(rdir);</span><br><span class="line">    <span class="built_in">free</span>(Rlist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sort_init</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifm</span> * <span class="title">pos</span>  =</span> (<span class="keyword">struct</span> ifm*)ptr1, * aftpos = (<span class="keyword">struct</span> ifm*)ptr2;</span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> strcoll(pos-&gt;rdirent.d_name,aftpos-&gt;rdirent.d_name) * order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sort_by_change_time</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifm</span> * <span class="title">pos</span>  =</span> (<span class="keyword">struct</span> ifm*)ptr1, * aftpos = (<span class="keyword">struct</span> ifm*)ptr2;</span><br><span class="line">    <span class="keyword">if</span>(pos-&gt;buf__stat.st_ctime&lt;aftpos-&gt;buf__stat.st_ctime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> * order;</span><br><span class="line">    <span class="keyword">if</span>(pos-&gt;buf__stat.st_ctime&gt;aftpos-&gt;buf__stat.st_ctime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> * order;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(<span class="keyword">struct</span> ifm * readifm)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(readifm-&gt;buf__stat.st_mode)</span><br><span class="line">    &amp;&amp;!(readifm-&gt;buf__stat.st_mode &amp; S_IXUSR))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,readifm-&gt;rdirent.d_name);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(readifm-&gt;buf__stat.st_mode)</span><br><span class="line">    &amp;&amp;(readifm-&gt;buf__stat.st_mode &amp; S_IXUSR))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;32m%s\033[0m&quot;</span>,readifm-&gt;rdirent.d_name);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(readifm-&gt;buf__stat.st_mode))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;34m%s\033[0m&quot;</span>,readifm-&gt;rdirent.d_name);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintWithL</span><span class="params">(<span class="keyword">struct</span> ifm *readifm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一列</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(readifm-&gt;buf__stat.st_mode))<span class="built_in">printf</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(readifm-&gt;buf__stat.st_mode))<span class="built_in">printf</span>(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(readifm-&gt;buf__stat.st_mode))<span class="built_in">printf</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISCHR(readifm-&gt;buf__stat.st_mode))<span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISCHR(readifm-&gt;buf__stat.st_mode))<span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有者权限</span></span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IRUSR?<span class="string">&quot;r&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IWUSR?<span class="string">&quot;w&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IXUSR?<span class="string">&quot;x&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="comment">//所属组权限</span></span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IRGRP?<span class="string">&quot;r&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IWGRP?<span class="string">&quot;w&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IXGRP?<span class="string">&quot;x&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他用户权限</span></span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IROTH?<span class="string">&quot;r&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IWOTH?<span class="string">&quot;w&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(readifm-&gt;buf__stat.st_mode &amp; S_IXOTH?<span class="string">&quot;x&quot;</span>:<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %lu&quot;</span>,readifm-&gt;buf__stat.st_nlink);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>,getpwuid(readifm-&gt;buf__stat.st_uid)-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>,getgrgid(readifm-&gt;buf__stat.st_gid)-&gt;gr_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu &quot;</span>,readifm-&gt;buf__stat.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">time</span> =</span> localtime(&amp;readifm-&gt;buf__stat.st_mtime);</span><br><span class="line">    <span class="type">char</span> time_buf[<span class="number">64</span>];</span><br><span class="line">    strftime(time_buf, <span class="number">64</span>, <span class="string">&quot;%m月 %d %H:%M&quot;</span>,time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,time_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现自己的-ls-命令&quot;&gt;&lt;a href=&quot;#实现自己的-ls-命令&quot; class=&quot;headerlink&quot; title=&quot;实现自己的 ls 命令&quot;&gt;&lt;/a&gt;实现自己的 ls 命令&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://plan.xiyoulinux.c</summary>
      
    
    
    
    
    <category term="Linux系统编程" scheme="http://aetherance.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>西邮Linux兴趣小组2022纳新题解</title>
    <link href="http://aetherance.github.io/2024/10/27/Linux2022/"/>
    <id>http://aetherance.github.io/2024/10/27/Linux2022/</id>
    <published>2024-10-27T07:13:44.000Z</published>
    <updated>2025-01-08T14:41:20.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西邮Linux兴趣小组2022纳新面试题"><a href="#西邮Linux兴趣小组2022纳新面试题" class="headerlink" title="西邮Linux兴趣小组2022纳新面试题"></a>西邮Linux兴趣小组2022纳新面试题</h1><p>感谢 <a href="https://github.com/L33Z22L11">Zhilu</a> 重新录入题目原件。好人一生平安。</p><ul><li>本题目只作为<code>Xiyou Linux兴趣小组</code>2022纳新面试的有限参考。</li><li>为节省版面，本试题的程序源码省去了<code>#include</code>指令。</li><li>本试题中的程序源码仅用于考察C语言基础，不应当作为C语言「代码风格」的范例。</li><li>题目难度随机排列。</li><li>所有题目编译并运行于<code>x86_64 GNU/Linux</code>环境。</li></ul><blockquote><p>学长寄语：<br>长期以来，西邮Linux兴趣小组的面试题以难度之高名扬西邮校内。我们作为出题人也清楚的知道这份试题略有难度。请别担心。<strong>若有同学能完成一半的题目，就已经十分优秀。</strong> 其次，相比于题目的答案，我们对你的思路和过程更感兴趣，或许你的答案略有瑕疵，但你正确的思路和对知识的理解足以为你赢得绝大多数的分数。最后，做题的过程也是学习和成长的过程，相信本试题对你更加熟悉的掌握C语言的一定有所帮助。祝你好运。我们FZ103见！</p></blockquote><p>Copyright © 2022 西邮Linux兴趣小组, All Rights Reserved.<br>本试题使用采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。</p><h2 id="0-我的计算器坏了？！"><a href="#0-我的计算器坏了？！" class="headerlink" title="0. 我的计算器坏了？！"></a>0. 我的计算器坏了？！</h2><p><code>2^10 = 1024</code>对应于十进制的4位，那么<code>2^10000</code>对应于十进制的多少位呢?</p><blockquote><p>lg[2]&#x3D;0.301029..</p></blockquote><p><code>2^10 = 1024</code>  &#x3D;&gt;<code>lg(2^10) = 10 * lg2</code>&#x3D;&gt;<code>lg(2^10) = 3</code><br><code>2^10000 </code> &#x3D;&gt; <code>lg(2^10000) = 10000 * lg2 = 3010</code><br>又因为<code>2^10 = 1024</code>对应十进制的位&emsp;所以<code>2^10000 </code>对应二进制的<code>3011</code>位</p><h2 id="1-printf还能这么玩？"><a href="#1-printf还能这么玩？" class="headerlink" title="1. printf还能这么玩？"></a>1. printf还能这么玩？</h2><p>尝试着解释程序的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">3</span> + <span class="number">2</span> &lt; <span class="number">2</span>) &gt; (<span class="number">3</span> + <span class="number">2</span> &gt; <span class="number">2</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to Xiyou Linux Group\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;Xiyou Linux Group - 2%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>()</code>的优先级最高，先计算<code>()</code>里的内容。<code>+</code>的优先级高于<code>&lt;</code>和<code>&gt;</code>所以先计算<code>3 + 2</code><br><code>3 + 2 &lt; 2</code>为假，返回 0。<code>3 + 2 &gt; 2</code>为真，返回 1。<code>0 &gt; 1</code>为假，进入<code>else</code>语句。<br><code>printf</code>的返回值是成功打印的字节数。<code>printf(&quot;&quot;)</code>成功打印了 0 个 字节，返回 0 。<br>返回的 0 又作为 中间的 <code>printf()</code>的参数，打印出 <strong>Xiyou Linux Group - 20</strong>，并且返回成功打印的字节数 22。22 作为最外层<code>printf()</code>的参数被打印出来。<br>最终打印的结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xiyou Linux Group - <span class="number">2022</span></span><br></pre></td></tr></table></figure><h2 id="2-你好你好你好呀！"><a href="#2-你好你好你好呀！" class="headerlink" title="2. 你好你好你好呀！"></a>2. 你好你好你好呀！</h2><ul><li>程序的输出有点奇怪，请尝试解释一下程序的输出吧。</li><li>请谈谈对<code>sizeof()</code>及<code>strlen()</code>的理解吧。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> p0[] = <span class="string">&quot;Hello,Linux&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p1 = <span class="string">&quot;Hello,Linux&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p2[<span class="number">11</span>] = <span class="string">&quot;Hello,Linux&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p0 == p1: %d, strcmp(p0, p2): %d\n&quot;</span>, p0 == p1, <span class="built_in">strcmp</span>(p0, p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p0): %zu, sizeof(p1): %zu, sizeof(*p2): %zu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(p0), <span class="keyword">sizeof</span>(p1), <span class="keyword">sizeof</span>(*p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(p0): %zu, strlen(p1): %zu\n&quot;</span>, <span class="built_in">strlen</span>(p0), <span class="built_in">strlen</span>(p1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sizeof()与strlen()的不同：<br>sizeof()<code>所计算出的是变量的大小 以字节为单位 </code>strlen()<code>所计算出的是字符串的长度 遇到&#39;\0&#39;时结束 不包含&#39;\0&#39; </code>strcmp()&#96;函数用于比较两个以’\0’结束的字符串 如果相同则返回 <em><strong>0</strong></em>     </p></blockquote><p><code>p0 == p1</code>比较的是两者的地址，两个不同局部变量的地址是不同的，所以返回 0。<code>strcmp()</code>比较的是两个以’\0’结尾的字符串(ascll码)是否相同，相同返回0。如果返回值大于0,则表示第一个字符串大于第二个字符串，如果返回值小于0,则表示第一个字符串小于第二个字符串。此处p2没有以<code>\0</code>结尾。p2中与p1中的<code>\0</code>对应的值是一个数组外的随机值，所以strcmp的返回值也是一个随机的值。<br><code>sizeof(p0)</code>求出的是字符串包含<code>\0</code>的大小&ensp;<code>sizeof(p1)</code>求出的指针的大小&ensp; <code>sizeof(*p2)</code>求出的是一个字符的大小 &ensp;<code>strlen(p0)</code>求出的是p0的长度 &ensp;<code>strlen(p1)</code>求出的是字符串p1的长度。</p><h2 id="3-换个变量名不行吗？"><a href="#3-换个变量名不行吗？" class="headerlink" title="3. 换个变量名不行吗？"></a>3. 换个变量名不行吗？</h2><p>请结合本题，分别谈谈你对C语言中「全局变量」和「局部变量」的「生命周期」理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = a + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a= %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数<code>test()</code>中优先使用在函数<code>test()</code>中定义的变量，在块{}里优先使用块{}里定义的变量。在块{}里，<code>int a = a + 1</code>的a都是在块{}里定义的a，由于a没有初始值，所以<code>a = a + 1</code>的结果不确定，第一个<code>printf()</code>打印的a的值不确定。 第二个<code>printf()</code>打印的就是在<code>test()</code>里块{}外定义的a。 <code>main()</code>里打印的是全局变量a。</p><h2 id="4-内存对不齐"><a href="#4-内存对不齐" class="headerlink" title="4. 内存对不齐"></a>4. 内存对不齐</h2><p><code>union</code>与<code>struct</code>各有什么特点呢，你了解他们的内存分配模式吗。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> l;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; UNION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> like;</span><br><span class="line">    UNION coin;</span><br><span class="line">    <span class="type">double</span> collect;</span><br><span class="line">&#125; STRUCT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof (UNION) = %zu\n&quot;</span>, <span class="keyword">sizeof</span>(UNION)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof (STRUCT) = %zu\n&quot;</span>, <span class="keyword">sizeof</span>(STRUCT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>union是共用体，struct是结构体。</p><blockquote><p>结构体变量的内存需要对齐 每个成员都有一个对齐数 对齐数等于默认对齐数和该成员大小的较小值</p></blockquote><blockquote><p>联合体中的成员公用同一块内存空间</p></blockquote><h2 id="5-Bitwise"><a href="#5-Bitwise" class="headerlink" title="5. Bitwise"></a>5. Bitwise</h2><ul><li>请使用纸笔推导出程序的输出结果。</li><li>请谈谈你对位运算的理解。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">4</span> | <span class="number">7</span>;</span><br><span class="line">    a &lt;&lt;= <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">5</span> &amp; <span class="number">7</span>;</span><br><span class="line">    b &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">6</span> ^ <span class="number">7</span>;</span><br><span class="line">    c = ~c;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d = (a ^ c) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> e = <span class="number">-63</span>;</span><br><span class="line">    e &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %d, b: %d, c: %d, d: %d\n&quot;</span>, a, b, c, (<span class="type">char</span>)d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e: %#x\n&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span><span class="number">00000100</span> <span class="number">5</span><span class="number">00000101</span><span class="number">6</span><span class="number">00000110</span></span><br><span class="line"><span class="number">7</span><span class="number">00000111</span><span class="number">7</span><span class="number">00000111</span><span class="number">7</span><span class="number">00000111</span></span><br><span class="line">a<span class="number">00000111</span> (<span class="number">7</span>)b<span class="number">00000101</span> (<span class="number">5</span>)c<span class="number">00000001</span> (<span class="number">1</span>)</span><br><span class="line">a(&lt;&lt;=<span class="number">3</span>)<span class="number">00111000</span> (<span class="number">56</span>)b(&gt;&gt;=<span class="number">3</span>)<span class="number">00000000</span> (<span class="number">0</span>)c(=~c)<span class="number">11111110</span> (<span class="number">254</span>)</span><br><span class="line"></span><br><span class="line">a<span class="number">00111000</span>e <span class="number">10000001</span></span><br><span class="line">c<span class="number">11111110</span></span><br><span class="line">a^c<span class="number">0000000011000110</span>e <span class="number">10000100</span> (<span class="number">4</span>)</span><br><span class="line">d<span class="number">0000011000110000</span> (<span class="number">1584</span>)</span><br><span class="line">(<span class="type">char</span>)d<span class="number">00110000</span> (<span class="number">48</span>)</span><br></pre></td></tr></table></figure><p>故 打印的结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: <span class="number">56</span>, b: <span class="number">0</span>, c: <span class="number">254</span>, d: <span class="number">48</span></span><br><span class="line">e: <span class="number">0x4</span></span><br></pre></td></tr></table></figure><h2 id="6-英译汉"><a href="#6-英译汉" class="headerlink" title="6. 英译汉"></a>6. 英译汉</h2><p>请说说下面数据类型的含义，谈谈<code>const</code>的作用。</p><ol><li><code>char *const p</code>。</li><li><code>char const *p</code>。</li><li><code>const char *p</code>。</li></ol><p>const修饰指针时，指针存储的地址不可改变。<br>const修饰变量时，变量的值不可改变。<br><code>char *const p</code>定义了一个<code>char</code>类型的指针常量 它存储的地址不可修改<br><code>char const *p</code>定义了一个<code>char</code>类型的常量指针 它存储的地址对应的变量值不可改变<br> <code>const char *p</code>相当于<code>char const *p</code></p><h2 id="7-汉译英"><a href="#7-汉译英" class="headerlink" title="7. 汉译英"></a>7. 汉译英</h2><p>请用变量<code>p</code>给出下面的定义:</p><ol><li>含有10个指向<code>int</code>的指针的数组。</li><li>指向含有10个<code>int</code>数组的指针。</li><li>含有3个「指向函数的指针」的数组，被指向的函数有1个<code>int</code>参数并返回<code>int</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*P)[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p[<span class="number">3</span>])(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="8-混乱中建立秩序"><a href="#8-混乱中建立秩序" class="headerlink" title="8. 混乱中建立秩序"></a>8. 混乱中建立秩序</h2><p>你对排序算法了解多少呢?<br>请谈谈你所了解的排序算法的思想、稳定性、时间复杂度、空间复杂度。</p><p>提示：动动你的小手敲出来更好哦~<br>例：<a href="https://github.com/itcharge/LeetCode-Py/blob/main/Contents/01.Array/02.Array-Sort/01.Array-Bubble-Sort.md">冒泡排序</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bubble_Sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;len - i - <span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序（Bubble Sort）基本思想：<br>经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。</p></blockquote><blockquote><p>稳定性的定义：排序前后两个相等的数相对位置不变，则算法稳定。</p></blockquote><p>冒泡排序的交换发生在相邻两个大小不同的元素之间，是稳定排序算法。</p><blockquote><p>算法的时间复杂度（time complexity）是一个函数，它定性描述该算法的运行时间。<br>算法的时间复杂度由算法中基本操作的执行次数来表示。<br><a href="https://www.bilibili.com/video/BV1f44y1A7rx?spm_id_from=333.788.videopod.episodes&vd_source=846bedf36429526f07cbc22bb584b100&p=3">时间复杂度</a></p></blockquote><p>冒泡排序的时间复杂度 ： 最好情况为O (n)&emsp;最差情况O(n^2)</p><blockquote><p>空间复杂度（space complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。<br><a href="https://www.hello-algo.com/chapter_computational_complexity/space_complexity/">空间复杂度</a> </p></blockquote><p>冒泡排序不需要额外的空间，因此冒泡排序的空间复杂度为O(1)</p><h2 id="9-手脑并用"><a href="#9-手脑并用" class="headerlink" title="9. 手脑并用"></a>9. 手脑并用</h2><p>请实现ConvertAndMerge函数：<br>拼接输入的两个字符串，并翻转拼接后得到的新字符串中所有字母的大小写。</p><p>提示:你需要为新字符串分配空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">convertAndMerge</span><span class="params">(<span class="comment">/*补全签名*/</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> words[<span class="number">2</span>][<span class="number">20</span>] = &#123;<span class="string">&quot;Welcome to Xiyou &quot;</span>, <span class="string">&quot;Linux Group 2022&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, words[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, words[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> *str = convertAndMerge(words);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">convertAndMerge</span><span class="params">(<span class="type">char</span> words[][<span class="number">20</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">strlen</span>(words[<span class="number">0</span>]),len2 = <span class="built_in">strlen</span>(words[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> * result = (<span class="type">char</span> *)<span class="built_in">malloc</span>((len1+len2)*<span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">//分配内存</span></span><br><span class="line">    <span class="built_in">sprintf</span>(result,<span class="string">&quot;%s%s&quot;</span>,words[<span class="number">0</span>],words[<span class="number">1</span>]);<span class="comment">//利用sprintf将两个字符串打印到一个字符串里实现拼接</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len1+len2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;result[i]&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            result[i]-=<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;result[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            result[i]+=<span class="number">32</span>;</span><br><span class="line">            <span class="comment">//反转大小写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-给你我的指针，访问我的心声"><a href="#10-给你我的指针，访问我的心声" class="headerlink" title="10. 给你我的指针，访问我的心声"></a>10. 给你我的指针，访问我的心声</h2><p>程序的输出有点奇怪，请尝试解释一下程序的输出吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> *temp = *(arr + i);</span><br><span class="line">        <span class="keyword">for</span> (; temp &lt; arr[<span class="number">5</span>]; temp++) *temp = a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>temp</code>先指向arr里的第一个数组，然后进入第二层for循环。在第二层for循环里循环25次，指针移动25次,a递增25次,arr[0]中记录的元素是前五次循环时a的值。arr[0]中的元素分别为0,1,2,3,4。同理arr[1],arr[2],arr[3],arr[4]记录的内容为 <code>25      26      27      28      29，5     46       47      48      49</code>,<code>60      61      62      63      64</code>,<code>70      71      72      73      74</code>所以打印的结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">25</span>      <span class="number">26</span>      <span class="number">27</span>      <span class="number">28</span>      <span class="number">29</span>      <span class="number">45</span>      <span class="number">46</span>      <span class="number">47</span>      <span class="number">48</span>      <span class="number">49</span>      <span class="number">60</span>      <span class="number">6162</span>       <span class="number">63</span>      <span class="number">64</span>      <span class="number">70</span>      <span class="number">71</span>      <span class="number">72</span>      <span class="number">73</span>      <span class="number">74</span></span><br></pre></td></tr></table></figure><h2 id="11-奇怪的参数"><a href="#11-奇怪的参数" class="headerlink" title="11. 奇怪的参数"></a>11. 奇怪的参数</h2><p>你了解argc和argv吗？<br>直接运行程序argc的值为什么是1？<br>程序会出现死循环吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        argc++;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>argv是<strong>命令行参数</strong> argc是参数的个数<br>程序至少有一个参数 <strong>文件名</strong> 所以在不提供其他参数的前提下，直接运行argc的值是1。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">       argc++;</span><br><span class="line">       <span class="keyword">if</span> (argc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)argv[<span class="number">0</span>]);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>会导致argc先递增，后溢出为<code>-2147483648</code>。然后会进入if，打印<code>argv[0]</code>,然后break，不会出现死循环。</p><h2 id="12-奇怪的字符"><a href="#12-奇怪的字符" class="headerlink" title="12. 奇怪的字符"></a>12. 奇怪的字符</h2><p>程序的输出有点奇怪，请尝试解释一下程序的输出吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> data1[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0x636c6557</span>, <span class="number">0x20656d6f</span>, <span class="number">0x58206f74</span>&#125;,</span><br><span class="line">                       &#123;<span class="number">0x756f7969</span>, <span class="number">0x6e694c20</span>, <span class="number">0x00000000</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> data2[] = &#123;<span class="number">0x47207875</span>, <span class="number">0x70756f72</span>, <span class="number">0x32303220</span>, <span class="number">0x00000a32</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *)data1;</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span> *)data2;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, a);</span><br><span class="line">    <span class="built_in">strcat</span>(buf, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>data1</code>强转为<code>(char*)</code>类型后，<code>data1</code>的数据被翻译为字符串，计算机通常采用小段储存，所以从第一个数据的最后一位开始翻译，直到<code>&#39;\0&#39;</code>为止。<code>data1</code>翻译的结果为<code>Welcome to Xiyou Lin</code> <code>data2</code>翻译的结果为<code>ux Group 2022</code>经过<code>strcpy(buf, a); strcat(buf, b);</code>的操作后，buf里存储的值为<code>Welcome to Xiyou Linux Group 2022</code><br>打印结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Xiyou Linux Group <span class="number">2022</span></span><br></pre></td></tr></table></figure><h2 id="13-小试宏刀"><a href="#13-小试宏刀" class="headerlink" title="13. 小试宏刀"></a>13. 小试宏刀</h2><ul><li>请谈谈你对<code>#define</code>的理解。</li><li>请尝试着解释程序的输出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(a, b, t) t = a; a = b; b = t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(a) a *a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPWHEN(a, b, t, cond) <span class="keyword">if</span> (cond) SWAP(a, b, t)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">3</span>;</span><br><span class="line">    SWAP(x, y, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d, tmp = %d\n&quot;</span>, x, y, tmp);</span><br><span class="line">    <span class="keyword">if</span> (x y) SWAP(x, y, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d, tmp = %d\n&quot;</span>, x, y, tmp);</span><br><span class="line">    SWAPWHEN(x, y, tmp, SQUARE(<span class="number">1</span> + <span class="number">2</span> + z++ + ++w) == <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = %d, w = %d, tmp = %d\n&quot;</span>, z, w, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/EleganceJiaBao/article/details/141252278?fromshare=blogdetail&sharetype=blogdetail&sharerId=141252278">宏定义相关知识</a><br>#define定义别名是在预处理时直接在文本中替换 如果没有加()，替换后的语句可能会和别的语句混在一起，输出意想不到的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">x = <span class="number">2</span>, y = <span class="number">1</span>, tmp = <span class="number">1</span></span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">2</span>, tmp = <span class="number">2</span></span><br><span class="line">x = <span class="number">2</span>, y = <span class="number">2</span></span><br><span class="line">z = <span class="number">5</span>, w = <span class="number">5</span>, tmp = <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="14-GNU-Linux命令-选做"><a href="#14-GNU-Linux命令-选做" class="headerlink" title="14. GNU&#x2F;Linux命令 (选做)"></a>14. GNU&#x2F;Linux命令 (选做)</h2><p>你知道以下命令的含义和用法吗：</p><p>注：<br>嘿！你或许对Linux命令不是很熟悉，甚至你没听说过Linux。<br>但别担心，这是选做题，不会对你的面试产生很大的影响！<br>了解Linux是加分项，但不了解也不扣分哦！</p><ul><li><code>ls</code>——列出工作目录</li><li><code>rm</code>——用于删除一个文件或者目录</li><li><code>whoami</code>——用于查找当前用户名</li></ul><p>请问你还了解哪些GNU&#x2F;Linux的命令呢。</p><blockquote><p>恭喜你做到这里！你的坚持战胜了绝大多数看到这份试题的同学。<br>或许你自己对答题的表现不满意,但别担心，请自信一点呐。<br>坚持到达这里已经证明了你的优秀。<br>还在等什么,快带上你的笔记本电脑，来FZ103面试吧!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;西邮Linux兴趣小组2022纳新面试题&quot;&gt;&lt;a href=&quot;#西邮Linux兴趣小组2022纳新面试题&quot; class=&quot;headerlink&quot; title=&quot;西邮Linux兴趣小组2022纳新面试题&quot;&gt;&lt;/a&gt;西邮Linux兴趣小组2022纳新面试题&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="西邮Linux兴趣小组" scheme="http://aetherance.github.io/tags/%E8%A5%BF%E9%82%AELinux%E5%85%B4%E8%B6%A3%E5%B0%8F%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>西邮Linux兴趣小组2023纳新题解</title>
    <link href="http://aetherance.github.io/2024/10/24/Linux2023/"/>
    <id>http://aetherance.github.io/2024/10/24/Linux2023/</id>
    <published>2024-10-24T07:13:44.000Z</published>
    <updated>2025-01-08T14:41:20.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西邮Linux兴趣小组2023纳新题"><a href="#西邮Linux兴趣小组2023纳新题" class="headerlink" title="西邮Linux兴趣小组2023纳新题"></a>西邮Linux兴趣小组2023纳新题</h1><ul><li>本题目只作为西邮 Linux 兴趣小组 2023 纳新面试的有限参考。</li><li>为节省版面，本试题的程序源码省去了 #include 指令。</li><li>本试题中的程序源码仅用于考察 C 语言基础，不应当作为 C 语言「代码风格」的范例。</li><li>所有题目编译并运行于 x86_64 GNU&#x2F;Linux 环境。</li></ul><h2 id="0-鼠鼠我啊，要被祸害了"><a href="#0-鼠鼠我啊，要被祸害了" class="headerlink" title="0. 鼠鼠我啊，要被祸害了"></a>0. 鼠鼠我啊，要被祸害了</h2><blockquote><p>有1000瓶水，其中有一瓶有毒，小白鼠只要尝一点带毒的水，24小时后就会准时死亡。至少要多少只小白鼠才能在24小时内鉴别出哪瓶水有毒？</p></blockquote><p><code>10</code>只即可<br>首先给这1000瓶水标上1～1000的二进制序号，<strong>最多需要十位二进制数</strong>就可以将1000瓶水全表示完。然后给十只标上1～10的序号，对应十个二进制位。如果某瓶水的序号中某一二进制位为1,则<strong>让对应序号的小鼠喝下这瓶水</strong>。最终根据24小时后小鼠的死亡情况可以得出一个十位二进制数，其所对应的十进制数就是有毒的水的序号。</p><h2 id="1-先预测一下"><a href="#1-先预测一下" class="headerlink" title="1. 先预测一下~"></a>1. 先预测一下~</h2><blockquote><p>按照函数要求输入自己的姓名试试~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 请你返回自己的姓名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a = welcome();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi, 我相信 %s 可以面试成功!\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种可行的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * name = <span class="string">&quot;name&quot;</span>;<span class="comment">//存储在全局区 函数执行完不会释放</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> name[] = <span class="string">&quot;name&quot;</span>;<span class="comment">//static修饰的变量存储在全局区 函数执行完不会释放</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>局部变量离开生命周期后就会被销毁 不能返回局部变量的地址  </p></blockquote><p>所以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[] = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可行</strong></p><h2 id="2-欢迎来到Linux兴趣小组"><a href="#2-欢迎来到Linux兴趣小组" class="headerlink" title="2. 欢迎来到Linux兴趣小组"></a>2. 欢迎来到Linux兴趣小组</h2><blockquote><p>有趣的输出，为什么会这样子呢~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptr0 = <span class="string">&quot;Welcome to Xiyou Linux!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ptr1[] = <span class="string">&quot;Welcome to Xiyou Linux!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (*ptr0 == *ptr1) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;Hello, Linux Group - 2%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> diff = ptr0 - ptr1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pointer Difference: %d\n&quot;</span>, diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题考察了<a href="https://blog.csdn.net/lrsnt/article/details/130837251?fromshare=blogdetail&sharetype=blogdetail&sharerId=130837251" title="printf的返回值是成功打印的字符数">printf的返回值</a>。<br><code>ptr0</code>指向W，<code>ptr1</code>指向的也是W，所以 <code>*ptr0==*ptr1</code> 为真，执行if语句。 printf(“”) 成功打印了 <code>0</code> 个字节，返回的 <code>0</code> 作为另一个printf函数的参数打印出<code>Hello, Linux Group - 20</code>，同时返回成功打印的字符数 <code>24</code>。最后一个printf函数打印出 <code>24</code>。最终打印的结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Linux Group - <span class="number">2024</span></span><br></pre></td></tr></table></figure><h2 id="3-一切都翻倍了吗"><a href="#3-一切都翻倍了吗" class="headerlink" title="3. 一切都翻倍了吗"></a>3. 一切都翻倍了吗</h2><blockquote><p>请尝试解释一下程序的输出。<br>请谈谈对sizeof()和strlen()的理解吧。<br>什么是sprintf()，它的参数以及返回值又是什么呢？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123;<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;, str[<span class="number">20</span>];</span><br><span class="line">    <span class="type">short</span> num = <span class="number">520</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\t%zu\t%zu\n&quot;</span>, <span class="keyword">sizeof</span>(*&amp;arr), <span class="keyword">sizeof</span>(arr + <span class="number">0</span>),</span><br><span class="line">           <span class="keyword">sizeof</span>(num = num2 + <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sprintf</span>(str, <span class="string">&quot;0x%x&quot;</span>, num) == num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\t%zu\n&quot;</span>, <span class="built_in">strlen</span>(&amp;str[<span class="number">0</span>] + <span class="number">1</span>), <span class="built_in">strlen</span>(arr + <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sizeof() 是一个运算符，而 strlen() 是一个函数。<br>sizeof() 计算的是变量所占用的内存字节数，而 strlen() 计算的是字符串中字符的个数。<br>strlen() 只能用于以 ‘\0’ 结尾的字符串。<br>sizeof() 括号中的语句不执行 而strlen() 括号中的语句会执行<br>sizeof() 计算字符串的长度，包含末尾的 ‘\0’。<br>strlen() 计算字符串的长度，不包含字符串末尾的 ‘\0’。</p></blockquote><blockquote><p>sprintf 与printf类似，不同的是printf是打印到stdout中，而sprintf是打印到一个字符串里。<br>关于sprintf的返回值：sprintf函数如果成功打印，则返回<strong>写入的字符总数</strong>，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p></blockquote><ul><li>第一个printf里的 <code>*&amp;arr</code> 其实就是<code>arr</code> &ensp;<code>sizeof(arr)</code>求出的就是整个数组的大小</li><li><code>arr+0</code>表明它是一个右移了 0 个单位的指针 <code>sizeof(arr+0)</code> 打印出来的就是(char*)类型指针的大小。</li><li><strong>因为sizeof()的结果是在编译时计算的，而strlen()的结果是在运行时计算的，所以sizeof()括号中的语句并不会执行。</strong><code>sizeof(num = num2 + 4)</code>计算出来的就是num的大小。</li><li>此处的sprintf将num转换成一个十六进制数打印到str里，并且返回了成功打印的字符数。成功打印的字符的数量不等于num，所以<code>sprintf(str, &quot;0x%x&quot;, num) == num</code>返回的是0，printf将其打印出来。</li><li><code>strlen(&amp;str[0] + 1)</code>相当于<code>strlen(str+1)</code>计算的是从str+1开始的长度，到’\0’为止。</li><li><code>strlen(arr+0)</code>打印的是以’\0’终止的整个字符串str的长度。</li></ul><h2 id="4-奇怪的输出"><a href="#4-奇怪的输出" class="headerlink" title="4. 奇怪的输出"></a>4. 奇怪的输出</h2><blockquote><p>程序的输出结果是什么？解释一下为什么出现该结果吧~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">64</span> &amp; <span class="number">127</span>;</span><br><span class="line">    <span class="type">char</span> b = <span class="number">64</span> ^ <span class="number">127</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">-64</span> &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="type">char</span> ch = a + b - c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d b = %d c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %d\n&quot;</span>, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01000000</span>(<span class="number">64</span>)</span><br><span class="line"><span class="number">01111111</span>(<span class="number">127</span>)按位与得</span><br><span class="line"><span class="number">01000000</span>(<span class="number">64</span>) <span class="comment">//a</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01000000</span>(<span class="number">64</span>)</span><br><span class="line"><span class="number">01111111</span>(<span class="number">127</span>)按位异或得</span><br><span class="line"><span class="number">00111111</span>(<span class="number">63</span>) <span class="comment">//b</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11000000</span>(<span class="number">-64</span>)(源码)</span><br><span class="line"><span class="number">10111111</span>(<span class="number">-64</span>)(反码)</span><br><span class="line"><span class="number">11000000</span>(<span class="number">-64</span>)(补码)</span><br><span class="line"><span class="number">11111111</span>(<span class="number">-1</span>) <span class="comment">//c(算术右移6位后)</span></span><br></pre></td></tr></table></figure><p>ch &#x3D; 64 + 63 - (-1) &#x3D; 128,但是char类型的大小为1个字节范围为 -128 ～ 127<br><code>01111111</code>(127) 再加1时会溢出为 <code>10000000</code>(-128)<br>最终打印的结果为 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">64</span>  b = <span class="number">63</span>  c = <span class="number">-1</span>    ch = <span class="number">-128</span></span><br></pre></td></tr></table></figure><h2 id="5-乍一看就不想看的函数"><a href="#5-乍一看就不想看的函数" class="headerlink" title="5. 乍一看就不想看的函数"></a>5. 乍一看就不想看的函数</h2><blockquote><p>“人们常说互联网凛冬已至，要提高自己的竞争力，可我怎么卷都卷不过别人，只好用一些奇技淫巧让我的代码变得高深莫测。”<br>这个func()函数的功能是什么？是如何实现的？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> func((a &amp; b) &lt;&lt; <span class="number">1</span>, a ^ b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>, b = <span class="number">9</span>, c = <span class="number">-7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, func(a, func(b, c)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a ^ b</code>是按位异或运算，相当于不进位的加法。而<code>(a &amp; b)  &lt;&lt; 1 </code>实现了进位。函数利用递归重复该过程，直到a &#x3D; 0（停止进位）时返回b。该过程实现的其实就是a和b两个整数的相加，最终返回的就是a+b的值。</p><blockquote><p>利用该函数求 1+1 的过程中 a和b的变化</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line"><span class="number">0001</span>    <span class="number">0001</span></span><br><span class="line"><span class="number">0010</span>    <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span>    <span class="number">0010</span></span><br></pre></td></tr></table></figure><p><code>func(b, c)</code>就是 <code>b+c</code>； printf()打印的其实就是 (a+(b+c))&ensp;最终结果为<code>6</code></p><h2 id="6-自定义过滤"><a href="#6-自定义过滤" class="headerlink" title="6. 自定义过滤"></a>6. 自定义过滤</h2><blockquote><p>请实现filter()函数：过滤满足条件的数组元素。<br>提示：使用函数指针作为函数参数并且你需要为新数组分配空间。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*Predicate)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> *<span class="title function_">filter</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> length, Predicate predicate,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> *resultLength)</span>; <span class="comment">/*补全函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPositive</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="keyword">return</span> num &gt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> resultLength;</span><br><span class="line">    <span class="type">int</span> *filteredNumbers = filter(<span class="built_in">array</span>, length, isPositive,</span><br><span class="line">                                  &amp;resultLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; resultLength; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, filteredNumbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(filteredNumbers);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码及注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*Predicate)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//给指向 参数为int 返回值为int 的函数指针定义一个别名predicate方便使用</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">filter</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> length, Predicate predicate,<span class="type">int</span> *resultLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//计数</span></span><br><span class="line">    <span class="type">int</span> * filteredNumbers = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*length);<span class="comment">//使用malloc动态开辟内存</span></span><br><span class="line">    assert(filteredNumbers);<span class="comment">//判断是否开辟成功 防止传入空指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*predicate)(<span class="built_in">array</span>[i]))<span class="comment">//通过函数指针调用筛选的函数 如果判断条件为真 将要筛选的数放入array</span></span><br><span class="line">        &#123;</span><br><span class="line">            filteredNumbers[count] = <span class="built_in">array</span>[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *resultLength = count;      <span class="comment">//长度变为count</span></span><br><span class="line">    <span class="keyword">return</span> filteredNumbers;<span class="comment">//返回筛选后的数组地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isPositive</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="keyword">return</span> num &gt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> resultLength;</span><br><span class="line">    <span class="type">int</span> *filteredNumbers = filter(<span class="built_in">array</span>, length, isPositive,</span><br><span class="line">                                  &amp;resultLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; resultLength; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, filteredNumbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(filteredNumbers);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-静…态…"><a href="#7-静…态…" class="headerlink" title="7. 静…态…"></a>7. 静…态…</h2><blockquote><p>如何理解关键字static？<br>static与变量结合后有什么作用？<br>static与函数结合后有什么作用？<br>static与指针结合后有什么作用？<br>static如何影响内存分配？</p></blockquote><p><code>static</code>意为“静态”。<br><code>static</code> 修饰的变量具有默认的初始值0。<br><code>static</code>修饰的<strong>局部变量</strong>的<strong>生命周期</strong>会延长至整个程序。<br>全局变量和函数被<code>static</code>修饰会使其不能被其他文件访问，可以防止命名冲突。<br><code>static</code>修饰的指针的<strong>生命周期</strong>会延长至整个程序。<br><code>static</code>修饰的变量会存储在<strong>全局区</strong>。</p><h2 id="8-救命！指针！"><a href="#8-救命！指针！" class="headerlink" title="8. 救命！指针！"></a>8. 救命！指针！</h2><blockquote><p>数组指针是什么？指针数组是什么？函数指针呢？用自己的话说出来更好哦，下面数据类型的含义都是什么呢？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*f1(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>数组指针，是一个指向数组的指针。<br>指针数组，是一个存放指针的数组。<br>函数指针，是一个指向函数的指针。<br><code>int (*p)[10];</code>是一个数组指针 指向一个int类型的 包含10个元素的数组。<br><code>const int* p[10];</code>是一个常量数组指针。它指向一个常量。<br><code>int (*f1(int))(int*, int);</code>  定义了一个返回值为int(*)(int *,int),参数为int的函数。</p><h2 id="9-咋不循环了"><a href="#9-咋不循环了" class="headerlink" title="9. 咋不循环了"></a>9. 咋不循环了</h2><blockquote><p>程序直接运行，输出的内容是什么意思？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">while</span> (argc) &#123;</span><br><span class="line">      ++argc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>, j = argc, k = <span class="number">1</span>;</span><br><span class="line">    i++ &amp;&amp; j++ || k++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d, k = %d\n&quot;</span>, i, j, k);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/f593256/article/details/131721231?fromshare=blogdetail&sharetype=blogdetail&sharerId=131721231">命令行参数相关知识</a><br><code>argc</code>是 <strong>命令行参数</strong> 默认值为1。 while()语句中<code>argc</code>递增 ，此过程中<code>argc</code>先溢出为-2147483648，再递增到0后退出循环。 <code>i = -1</code> ; <code>j = argc = 0</code> ; <code>k = 1</code>;<br>&amp;&amp;的优先级高于|| ， 所以  <code>i++ &amp;&amp; j++</code> 先进行。后置递增运算符在语句执行完后才进行递增，所以<code>i++ &amp;&amp; j++</code> 中&amp;&amp;左边部分为真,继续执行&amp;&amp;右边部分，j递增。但是j在递增之前为0,所以<code>i++ &amp;&amp; j++</code>为假，继续执行||右边的部分,k递增。<br><code>EXIT_SUCCESS</code>定义于 头文件<code>&lt;stdlib.h&gt;</code>，<code>return EXIT_SUCCESS</code> 相当于  <code>return 0</code></p><h2 id="10-到底是不是TWO"><a href="#10-到底是不是TWO" class="headerlink" title="10. 到底是不是TWO"></a>10. 到底是不是TWO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAL(a) a * a * a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGIC_CAL(a, b) CAL(a) + CAL(b)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> nums = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">16</span> / CAL(<span class="number">2</span>) == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m TWO(ﾉ&gt;ω&lt;)ﾉ\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums = MAGIC_CAL(++nums, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/EleganceJiaBao/article/details/141252278?fromshare=blogdetail&sharetype=blogdetail&sharerId=141252278">宏定义相关知识</a><br>#define定义别名是在预处理时直接在文本中替换 所以<code>if(16 / CAL(2) == 2)</code>会被直接替换为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">16</span> / <span class="number">2</span> * <span class="number">2</span> * <span class="number">2</span> == <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>显然if条件为假 不会打印 <code>I&#39;m TWO(ﾉ&gt;ω&lt;)ﾉ</code><br>else{}中定义的nums离开else{}就会被销毁，所以printf打印出来的就是一开始定义的nums的值 <code>1</code></p><h2 id="11-克隆困境"><a href="#11-克隆困境" class="headerlink" title="11. 克隆困境"></a>11. 克隆困境</h2><blockquote><p>试着运行一下程序，为什么会出现这样的结果？</p></blockquote><p>直接将s2赋值给s1会出现哪些问题，应该如何解决？请写出相应代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeStudent</span><span class="params">(<span class="keyword">struct</span> Student *student, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    student-&gt;name = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(student-&gt;name, name);</span><br><span class="line">    student-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>, <span class="title">s2</span>;</span></span><br><span class="line">    initializeStudent(&amp;s1, <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    initializeStudent(&amp;s2, <span class="string">&quot;Jerry&quot;</span>, <span class="number">28</span>);</span><br><span class="line">    s1 = s2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1的姓名: %s 年龄: %d\n&quot;</span>, s1.name, s1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2的姓名: %s 年龄: %d\n&quot;</span>, s2.name, s2.age);</span><br><span class="line">    <span class="built_in">free</span>(s1.name);</span><br><span class="line">    <span class="built_in">free</span>(s2.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>s2</code>直接赋值给<code>s1</code>属于<strong>浅拷贝</strong>。<code>s2</code>中的<code>age</code>可以成功复制，但是复制使用<code>malloc</code>动态开辟的<code>name</code>时只能将<code>s2.name</code>的地址赋给<code>s1.name</code>。在使用<code>free</code>释放时，会将<code>s2.name</code>地址对应的内存重复释放，造成错误。<br>解决方法：使用strcpy()将s2.name复制到已经开辟好的s1.name的空间中即可。<br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeStudent</span><span class="params">(<span class="keyword">struct</span> Student *student, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    student-&gt;name = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(student-&gt;name, name);</span><br><span class="line">    student-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Copy</span><span class="params">(<span class="keyword">struct</span> Student * s1,<span class="keyword">struct</span> Student * s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    s1-&gt;age = s2-&gt;age;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1-&gt;name,s2-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>, <span class="title">s2</span>;</span></span><br><span class="line">    initializeStudent(&amp;s1, <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    initializeStudent(&amp;s2, <span class="string">&quot;Jerry&quot;</span>, <span class="number">28</span>);</span><br><span class="line">    Copy(&amp;s1,&amp;s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 的姓名: %s 年龄: %d\n&quot;</span>, s1.name, s1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 的姓名: %s 年龄: %d\n&quot;</span>, s2.name, s2.age);</span><br><span class="line">    <span class="built_in">free</span>(s1.name);</span><br><span class="line">    <span class="built_in">free</span>(s2.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://yx-codec-conductor.blog.csdn.net/article/details/136889144?fromshare=blogdetail&sharetype=blogdetail&sharerId=136889144">深拷贝与浅拷贝</a></p><h2 id="12-你好，我是内存"><a href="#12-你好，我是内存" class="headerlink" title="12. 你好，我是内存"></a>12. 你好，我是内存</h2><blockquote><p>作为一名合格的C-Coder，一定对内存很敏感吧~来尝试理解这个程序吧！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structure</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> foo;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="type">int</span> integer;</span><br><span class="line">      <span class="type">char</span> <span class="built_in">string</span>[<span class="number">11</span>];</span><br><span class="line">      <span class="type">void</span> *pointer;</span><br><span class="line">    &#125; node;</span><br><span class="line">    <span class="type">short</span> bar;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> baz;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">7</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">0x590ff23c</span>, <span class="number">0x2fbc5a4d</span>, <span class="number">0x636c6557</span>, <span class="number">0x20656d6f</span>,</span><br><span class="line">                 <span class="number">0x58206f74</span>, <span class="number">0x20545055</span>, <span class="number">0x6577202c</span>, <span class="number">0x6d6f636c</span>,</span><br><span class="line">                 <span class="number">0x6f742065</span>, <span class="number">0x79695820</span>, <span class="number">0x4c20756f</span>, <span class="number">0x78756e69</span>,</span><br><span class="line">                 <span class="number">0x6f724720</span>, <span class="number">0x5b207075</span>, <span class="number">0x33323032</span>, <span class="number">0x7825005d</span>,</span><br><span class="line">                 <span class="number">0x636c6557</span>, <span class="number">0x64fd6d1d</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ((<span class="keyword">struct</span> structure *)arr)-&gt;node.<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/bhbhhyg/article/details/116888685?fromshare=blogdetail&sharetype=blogdetail&sharerId=116888685">字节序与大小端</a><br><code>(struct structure *)arr</code> 将arr强转为结构体指针类型访问联合体中的string成员，联合体union内的成员共用一块内存，内存大小至少为8。联合体在结构体内的对齐数为8,又因为前面还有一个int类型，所以联合体存储在结构体中偏移量为8的地址处。arr强转为结构体指针后访问联合体node中的成员string，相当于跳过了数组中的两个int类型元素，指向第三个元素<code>0x636c6557</code>。<br>并且计算机一般采用小端存储，也就是对于arr中的第三个元素<code>0x636c6557</code> <code>57</code>存在低地址处，printf打印时从<code>57</code>开始，将十六进制ascll码转换为字符，逐个打印，直到遇到’\0’。最终打印出来的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to XUPT , welcome to Xiyou Linux Group [<span class="number">2023</span>]</span><br></pre></td></tr></table></figure><h2 id="13-GNU-Linux-选做"><a href="#13-GNU-Linux-选做" class="headerlink" title="13. GNU&#x2F;Linux (选做)"></a>13. GNU&#x2F;Linux (选做)</h2><blockquote><p>注：嘿！你或许对Linux命令不是很熟悉，甚至你没听说过Linux。但别担心，这是选做题，了解Linux是加分项，但不了解也不扣分哦！<br>你知道cd命令的用法与 &#x2F; . ~ 这些符号的含义吗？<br>请问你还懂得哪些与 GNU&#x2F;Linux 相关的知识呢~</p></blockquote><blockquote><p>cd：切换工作目录<br>&#x2F; 根目录 &ensp; . 当前目录 &ensp; ~ user目录</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;西邮Linux兴趣小组2023纳新题&quot;&gt;&lt;a href=&quot;#西邮Linux兴趣小组2023纳新题&quot; class=&quot;headerlink&quot; title=&quot;西邮Linux兴趣小组2023纳新题&quot;&gt;&lt;/a&gt;西邮Linux兴趣小组2023纳新题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="西邮Linux兴趣小组" scheme="http://aetherance.github.io/tags/%E8%A5%BF%E9%82%AELinux%E5%85%B4%E8%B6%A3%E5%B0%8F%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>西邮Linux兴趣小组2024纳新题解</title>
    <link href="http://aetherance.github.io/2024/10/22/Linux2024/"/>
    <id>http://aetherance.github.io/2024/10/22/Linux2024/</id>
    <published>2024-10-22T07:13:44.000Z</published>
    <updated>2025-01-08T14:41:20.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西邮Linux兴趣小组2024纳新题"><a href="#西邮Linux兴趣小组2024纳新题" class="headerlink" title="西邮Linux兴趣小组2024纳新题"></a>西邮Linux兴趣小组2024纳新题</h1><ul><li>本题目只作为西邮 Linux 兴趣小组 2024 纳新面试的有限参考。</li><li>为节省版面，本试题的程序源码省去了 #include 指令。</li><li>本试题中的程序源码仅用于考察 C 语言基础，不应当作为 C 语言「代码风格」的范例。</li><li>所有题目编译并运行于 x86_64 GNU&#x2F;Linux 环境。</li></ul><h2 id="0-聪明的吗喽"><a href="#0-聪明的吗喽" class="headerlink" title="0. 聪明的吗喽"></a>0. 聪明的吗喽</h2><blockquote><p>一个小猴子边上有 100 根香蕉，它要走过 50 米才能到家，每次它最多搬 50 根香蕉，（多了就拿不动了），它每走 1 米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。<br>（提示：他可以把香蕉放下往返走，但是必须保证它每走一米都能有香蕉吃。也可以走到 n 米时，放下一些香蕉，拿着 n 根香蕉走回去重新搬 50 根。）</p></blockquote><p>刚开始应该让猴子搬既可能多的香蕉，所以让猴子先把50根香蕉搬1m，再折返回去将另外的50根香蕉搬1m。<em><strong>该过程将所有的香蕉搬1m会消耗3根香蕉</strong></em>。按照此过程将所有的香蕉搬16米，香蕉还剩 50 + 2 根 ，距离终点 34 米。此时先让猴子把50根香蕉搬1m（该过程会消耗1根香蕉）。无论是否回去搬运剩下的两根香蕉，最终都只剩下49根香蕉，距离终点33米。<br>猴子搬运1m消耗1根香蕉，到达终点时剩下49 - 33 &#x3D; <code>16</code>根香蕉。</p><h2 id="1-西邮Linux欢迎你啊"><a href="#1-西邮Linux欢迎你啊" class="headerlink" title="1. 西邮Linux欢迎你啊"></a>1. 西邮Linux欢迎你啊</h2><blockquote><p>请解释以下代码的运行结果。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">2024</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a &gt;= <span class="number">0</span>; a--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;Hi guys! Join Linux - 2%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题主要考察了unsigned int类型和printf函数</p><blockquote><p>无符号整型（unsigned int）的取值范围是从0到2^32 - 1，即0到4294967295。</p></blockquote><p>由于<a href="https://blog.csdn.net/m0_64144913/article/details/127133929?fromshare=blogdetail&sharetype=blogdetail&sharerId=127133929&sharerefer=PC&sharesource=weixin_74355874&sharefrom=from_link" title="unsigned int">无符号整型</a>变量a只能表示0和正整数，且for循环的判断条件为 <em><strong>a&gt;&#x3D;0</strong></em> 所以printf语句会无限循环执行。 </p><p>printf函数的返回值为<strong>成功打印的字符数</strong>。<br>本段代码先执行最内层的printf函数 成功打印了0个字节 因此返回 <em><strong>0</strong></em>。<br>返回的 0 又作为中间层printf函数的参数，打印出 <code>Hi guys! Join Linux - 20</code><br>同时返回成功打印的字符数<em><strong>24</strong></em>。<br>最后，最外层的printf打印出<code>24</code>。</p><p>故代码的运行结果为 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hi guys! Join Linux - <span class="number">2024</span></span><br><span class="line">Hi guys! Join Linux - <span class="number">2024</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="2-眼见不一定为实"><a href="#2-眼见不一定为实" class="headerlink" title="2. 眼见不一定为实"></a>2. 眼见不一定为实</h2><blockquote><p>输出为什么和想象中不太一样？<br>你了解 sizeof() 和 strlen() 吗？他们的区别是什么？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> p0[] = <span class="string">&quot;I love Linux&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p1 = <span class="string">&quot;I love Linux\0Group&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p2[] = <span class="string">&quot;I love Linux\0&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, <span class="built_in">strcmp</span>(p0, p1), <span class="built_in">strcmp</span>(p0, p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, <span class="keyword">sizeof</span>(p0) == <span class="keyword">sizeof</span>(p1), <span class="built_in">strlen</span>(p0) == <span class="built_in">strlen</span>(p1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>sizeof()</code>所计算出的是变量的大小 以字节为单位<br><code>strlen()</code>所计算出的是字符串的长度 遇到’\0’时结束 不包含’\0’<br><code>strcmp()</code>函数用于比较两个以’\0’结束的字符串 如果相同则返回 <em><strong>0</strong></em>     </p></blockquote><p>p1和p0相同,p1和p2相同,<code>strcmp()</code>返回 <em><strong>0</strong></em>,所以第一个printf打印出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>sizeof(p0)不等于sizeof(p1) 因此 <code>sizeof(p0) == sizeof(p1)</code>为假 返回 <em><strong>0</strong></em><br>strlen(p0)等于strlen(p1) 因此 <code>strlen(p0) == strlen(p1)</code>为真 返回 <em><strong>1</strong></em><br>所以最终的打印结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="3-1-1-1-0-0-1"><a href="#3-1-1-1-0-0-1" class="headerlink" title="3. 1.1 - 1.0 !&#x3D; 0.1"></a>3. 1.1 - 1.0 !&#x3D; 0.1</h2><blockquote><p>为什么会这样，除了下面给出的一种方法，还有什么方法可以避免这个问题？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.0</span>, b = <span class="number">1.1</span>, ex = <span class="number">0.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b - a == ex is %s\n&quot;</span>, (b - a == ex) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="type">int</span> A = a * <span class="number">10</span>, B = b * <span class="number">10</span>, EX = ex * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B - A == EX is %s\n&quot;</span>, (B - A == EX) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算机存储浮点数时，会将其转换为<strong>二进制</strong>进行存储，转换一些小数时，会超出float能够存储的位数，造成精度的损失<br>可以提供误差范围，如果结果在误差范围内则可以判定&#x3D;&#x3D;左右两边相等<br>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.0</span>, b = <span class="number">1.1</span>, ex = <span class="number">0.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b - a == ex is %s\n&quot;</span>, (b - a &lt;= ex + <span class="number">0.00001</span>) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-听说爱用位运算的人技术都不太差"><a href="#4-听说爱用位运算的人技术都不太差" class="headerlink" title="4. 听说爱用位运算的人技术都不太差"></a>4. 听说爱用位运算的人技术都不太差</h2><blockquote><p>解释函数的原理，并分析使用位运算求平均值的优缺点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end)</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> leftAvg = average(nums, start, mid);</span><br><span class="line">    <span class="type">int</span> rightAvg = average(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> (leftAvg &amp; rightAvg) + ((leftAvg ^ rightAvg) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>average()</code>利用递归和位运算求平均值。<br>如一组数据 1 3 4 7 9 2 1 8 5 <code>average()</code>先找到其中间项mid，再将其分为两个部分<br><code>1 3 4 7 9</code>  <code>2 1 8 5 </code> if条件为假,继续分割。<code>1 3 4</code> <code>7 9</code> <code>2 1</code> <code>8 5</code><br>例如对于<code>79</code>再次进入<code>average()</code>时 leftAvg &#x3D; 7 rightAvg &#x3D; 9 函数返回位运算计算的平均值 <code>79</code> &#x3D;&gt; <code>8</code> 返回的平均值被<em>leftAvg</em>或者<em>rightAvg</em>接收继续参与到求平均值的运算中。<br>最终可以求出数组中所有元素的平均值。</p><p> 使用位运算求平均值的优点是运算速度较快 缺点是可读性较差</p><h2 id="5-全局还是局部"><a href="#5-全局还是局部" class="headerlink" title="5. 全局还是局部!!!"></a>5. 全局还是局部!!!</h2><blockquote><p>先思考输出是什么，再动动小手运行下代码，看跟自己想得结果一样不一样 &gt;-&lt;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j);</span><br><span class="line">    <span class="keyword">return</span> i % j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个i是全局变量 第二个i是函数体内的局部变量<br>在函数体内优先使用函数体内的局部变量,i &#x3D; 10。<br><code>i&gt;5</code>成立 执行<code>i++</code><br>j 是一个 <strong>静态全局变量</strong> 在函数体内 j &#x3D; 15<br>printf打印出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">11</span>, j = <span class="number">15</span></span><br></pre></td></tr></table></figure><p><code>func()</code>返回<code>i%j</code> &#x3D; <code>11</code>  所以 a &#x3D; 11<br>main()里的第一个printf()打印出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">11</span></span><br><span class="line">i = <span class="number">1</span>, j = <span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="6-指针的修罗场：改还是不改，这是个问题"><a href="#6-指针的修罗场：改还是不改，这是个问题" class="headerlink" title="6. 指针的修罗场：改还是不改，这是个问题"></a>6. 指针的修罗场：改还是不改，这是个问题</h2><blockquote><p>指出以下代码中存在的问题，并帮粗心的学长改正问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> q = &amp;b;</span><br><span class="line">    *p = <span class="number">3</span>, q = &amp;a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> r = &amp;a;</span><br><span class="line">    *r = <span class="number">4</span>, r = &amp;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const int *p = &amp;a;</code>p是一个<em><strong>常量指针</strong></em> 它指向的值不可修改<br><code>int * const q = &amp;b;</code>q是一个<em><strong>指针常量</strong></em> 它的指向不可修改<br>因此 <code>*p = 3, q = &amp;a;</code>错误<br>可以改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">3</span>;</span><br><span class="line">p = &amp; temp;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*q = a;</span><br></pre></td></tr></table></figure><p> <code>const int * const r = &amp;a;</code>定义的r是一个<em><strong>常量指针常量</strong></em> 它的指向和指向的值都不可以修改<br> 可以改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="number">4</span>;</span><br><span class="line">r = &amp;temp;</span><br><span class="line">*r = b;</span><br></pre></td></tr></table></figure><h2 id="7-物极必反？"><a href="#7-物极必反？" class="headerlink" title="7. 物极必反？"></a>7. 物极必反？</h2><blockquote><p>你了解 argc 和 argv 吗，这个程序里的 argc 和 argv 是什么？<br>程序输出是什么？解释一下为什么。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (argc++ &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = argc, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (--a || b++ &amp;&amp; c--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; argv[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>argv[]是<strong>命令行参数</strong><br>argc是从命令行传给程序的参数个数(至少为1) </p></blockquote><p> 在没有传入参数时 argc &#x3D; 1<br> <code>while (argc++ &gt; 0);</code>argc递增直到溢出为<code>-2147483648</code><br> <code>b = argc = -2147483648</code><br> <code>--a</code>先递减 再判断 a &#x3D; 0为假 故需要判断 <code>b++ &amp;&amp; c--</code><br> <code>c--</code>c先使用后递减 c&#x3D;0 为假 故 <code>b++ &amp;&amp; c--</code>为假  不进入if语句<br> 最终printf打印<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>, b = <span class="number">-2147483647</span>, c = <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h2 id="8-指针？数组？数组指针？指针数组？"><a href="#8-指针？数组？数组指针？指针数组？" class="headerlink" title="8. 指针？数组？数组指针？指针数组？"></a>8. 指针？数组？数组指针？指针数组？</h2><blockquote><p>在printf()主函数中定义如下变量：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span>(*b)[<span class="number">2</span>] = &amp;a;</span><br><span class="line">    <span class="type">int</span> *c[<span class="number">2</span>] = &#123;a, a + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说说这些输出分别是什么？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, a + <span class="number">1</span>, &amp;a, &amp;a + <span class="number">1</span>, *(a + <span class="number">1</span>), <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(&amp;a)</span><br><span class="line">*b, *b + <span class="number">1</span>, b, b + <span class="number">1</span>, *(*b + <span class="number">1</span>), <span class="keyword">sizeof</span>(*b), <span class="keyword">sizeof</span>(b)</span><br><span class="line">c, c + <span class="number">1</span>, &amp;c, &amp;c + <span class="number">1</span>, **(c + <span class="number">1</span>), <span class="keyword">sizeof</span>(c), <span class="keyword">sizeof</span>(&amp;c)</span><br></pre></td></tr></table></figure><p> <code>int a[2] = &#123;4, 8&#125;;</code>定义了一个数组<br><code>int(*b)[2] = &amp;a;</code>定义了一个数组指针 步长为2 指向a<br><code>int *c[2] = &#123;a, a + 1&#125;;</code>定义了一个指针数组 其中元素为 a ， a+1</p><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, a + <span class="number">1</span>, &amp;a, &amp;a + <span class="number">1</span>, *(a + <span class="number">1</span>), <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(&amp;a)</span><br></pre></td></tr></table></figure><p>输出的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffd9e2f1e48</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e4c</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e48</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e50</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p><code>a</code>是数组的首地址 打印出来的是第一个元素 4 的地址<br><code>a+1</code>指向数组的第二个元素 8 打印出来的是 8 的地址<br><code>&amp;a</code>是整个数组的地址 与数组的首地址相同 <strong>步长是整个数组的长度</strong><br><code>&amp;a</code>指向数组的第一个元素 <code>&amp;a+1</code> 在此基础上右移了整个数组的长度<br><code>a+1</code>指向8 所以*(a+1) 等于 8<br><code>sizeof(a)</code>计算出整个数组的大小 即 8<br><code>sizeof(&amp;a)</code>计算出的是指针的大小 64位下为 8</p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*b, *b + <span class="number">1</span>, b, b + <span class="number">1</span>, *(*b + <span class="number">1</span>), <span class="keyword">sizeof</span>(*b), <span class="keyword">sizeof</span>(b)</span><br></pre></td></tr></table></figure><p>输出的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffd9e2f1e48</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e4c</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e48</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e50</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>数组指针b指向的是a   &#x3D;&gt; *b等于a &#x3D;&gt; b &#x3D; &amp;a<br>所以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*b, *b + <span class="number">1</span>, b, b + <span class="number">1</span>, *(*b + <span class="number">1</span>), <span class="keyword">sizeof</span>(*b), <span class="keyword">sizeof</span>(b)</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, a + <span class="number">1</span>, &amp;a, &amp;a + <span class="number">1</span>, *(a + <span class="number">1</span>), <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(&amp;a)</span><br></pre></td></tr></table></figure><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c, c + <span class="number">1</span>, &amp;c, &amp;c + <span class="number">1</span>, **(c + <span class="number">1</span>), <span class="keyword">sizeof</span>(c), <span class="keyword">sizeof</span>(&amp;c)</span><br></pre></td></tr></table></figure><p>输出的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffd9e2f1e50</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e58</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e50</span></span><br><span class="line"><span class="number">0x7ffd9e2f1e60</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p><code>c</code>是指针数组c的首地址 打印出来的是该数组的地址 也是第一个元素a的首地址<br><code>c+1</code>指向的是第二个元素 a+1 打印出来的是 a+1 的地址<br><code>&amp;c</code> <code>&amp;c+1</code> 与 <code>&amp;a</code> <code>&amp;a+1</code> 同理<br><code>**(c+1)</code> 等同于<code>*(a+1)</code> 即 8<br><code>sizeof(c)</code>得到的是数组c的大小 该数组是一个指针数组 共有两个元素 在64位下结果为 16<br><code>sizeof(&amp;c)</code>得到的是指针的大小 64位下结果为8</p><h2 id="9-嘻嘻哈哈，好玩好玩"><a href="#9-嘻嘻哈哈，好玩好玩" class="headerlink" title="9. 嘻嘻哈哈，好玩好玩"></a>9. 嘻嘻哈哈，好玩好玩</h2><blockquote><p>在宏的魔法下，数字与文字交织，猜猜结果是什么？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x *x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (a &gt; b) ? a : b;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(x) printf(<span class="string">&quot;嘻嘻，结果你猜对了吗，包%d滴\n&quot;</span>, x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(a, b) a##b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">CONCAT</span><span class="params">(x, <span class="number">1</span>)</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">CONCAT</span><span class="params">(y, <span class="number">2</span>)</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> max = MAX(SQUARE(x1 + <span class="number">1</span>), SQUARE(y2))</span><br><span class="line">    PRINT(max)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在宏定义中 a##b代表将a和b连在一起<br>所以前两行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 = <span class="number">5</span>;</span><br><span class="line">y2 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>#define在编译前直接在文本中替换<br>所以第三行和第四行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = (x1 + <span class="number">1</span> * x1 + <span class="number">1</span> &gt; y2 * y2)? x1 + <span class="number">1</span> * x1 + <span class="number">1</span> : y2 * y2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;嘻嘻，结果你猜对了吗，包%d滴\n&quot;</span>, max);</span><br></pre></td></tr></table></figure><p>max &#x3D; x1 + 1 * x1 + 1 &#x3D; 11<br>打印的结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嘻嘻，结果你猜对了吗，包<span class="number">11</span>滴</span><br></pre></td></tr></table></figure><h2 id="10-我写的排序最快"><a href="#10-我写的排序最快" class="headerlink" title="10. 我写的排序最快"></a>10. 我写的排序最快</h2><blockquote><p>写一个 your_sort 函数，要求不能改动 main 函数里的代码，对 arr1 和 arr2 两个数组进行升序排序并剔除相同元素，最后将排序结果放入 result 结构体中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(arr1[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(arr2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    result result;</span><br><span class="line">    your_sort(arr1, len1, arr2, len2, &amp;result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, result.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>()<span class="built_in">free</span>(result.arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> * arr;</span><br><span class="line">   <span class="type">int</span> len;</span><br><span class="line">&#125;result;</span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_Sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;len - i - <span class="number">1</span>;j++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">your_sort</span><span class="params">(<span class="type">int</span> arr1[],<span class="type">int</span> len1,<span class="type">int</span> arr2[],<span class="type">int</span> len2,result * result)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> len_temp = len1 + len2,count = <span class="number">0</span>;</span><br><span class="line">   result-&gt;arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(len_temp * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//使用malloc分配空间</span></span><br><span class="line">   <span class="keyword">if</span>(result-&gt;arr==<span class="literal">NULL</span>)<span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//检测是否开辟成功</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      result-&gt;arr[count] = arr1[i];</span><br><span class="line">      count++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len2;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      result-&gt;arr[count] = arr2[i];</span><br><span class="line">      count++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将两个数组合为一个数组</span></span><br><span class="line">   result-&gt;len = count;</span><br><span class="line">   Bubble_Sort(result-&gt;arr,result-&gt;len);<span class="comment">//排序</span></span><br><span class="line">   <span class="type">int</span> * arr_temp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * count);</span><br><span class="line">   <span class="keyword">if</span>(arr_temp == <span class="literal">NULL</span>)<span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//检测是否开辟成功</span></span><br><span class="line">   <span class="type">int</span> _count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;result-&gt;len;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(result-&gt;arr[i]!=result-&gt;arr[i+<span class="number">1</span>])<span class="comment">//如果不同存入临时数组</span></span><br><span class="line">      &#123;</span><br><span class="line">         arr_temp[_count] = result-&gt;arr[i];</span><br><span class="line">         _count++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   result-&gt;len = _count;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;result-&gt;len;i++)<span class="comment">//将筛选后的元素放回数组</span></span><br><span class="line">   &#123;</span><br><span class="line">      result-&gt;arr[i] = arr_temp[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(arr_temp);<span class="comment">//释放临时使用的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(arr1[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(arr2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    result result;</span><br><span class="line">    your_sort(arr1, len1, arr2, len2, &amp;result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, result.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(result.arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-猜猜我是谁"><a href="#11-猜猜我是谁" class="headerlink" title="11. 猜猜我是谁"></a>11. 猜猜我是谁</h2><blockquote><p>在指针的迷宫中，五个数字化身为神秘的符号，等待被逐一揭示。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *a[] = &#123;(<span class="type">void</span> *)<span class="number">1</span>, (<span class="type">void</span> *)<span class="number">2</span>, (<span class="type">void</span> *)<span class="number">3</span>, (<span class="type">void</span> *)<span class="number">4</span>, (<span class="type">void</span> *)<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((<span class="type">char</span> *)a + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span> *)(<span class="type">char</span> *)a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((<span class="type">int</span> *)a + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, *((<span class="type">long</span> <span class="type">long</span> *)a + <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((<span class="type">short</span> *)a + <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void *a[] = &#123;(void *)1, (void *)2, (void *)3, (void *)4, (void *)5&#125;;</code> 定义了一个void<em>类型的数组 其中每个元素都是void</em>类型的值 即每个元素都是一个十六进制的整形<br><code> printf(&quot;%d\n&quot;, *((char *)a + 1));</code>将a强转为(char*)类型的指针 a 指向(void*)1 即0000000000000001<br>一个(void*)类型占8个字节 包括16个十六进制位 所以一个十六进制位占0.5个字节<br>并且计算机一般采用小段存储<br>所以用 <code> </code> 标记 (char*)a的指向为 00000000000000<code>01</code><br>(char*)a+1为 000000000000<code>00</code>01<br>所以<code>printf(&quot;%d\n&quot;, *((char *)a + 1));</code>打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>同理 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((<span class="type">int</span> *)a + <span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, *((<span class="type">long</span> <span class="type">long</span> *)a + <span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((<span class="type">short</span> *)a + <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>第二行的<code>printf(&quot;%d\n&quot;, *(int *)(char *)a + 1);</code>是将a强转为(char*)类型后再强转为(int*)类型后解引用<br>*(int *)(char *)a &#x3D; (void *)1<br>printf(“%d\n”, *(int *)(char *)a + 1); 相当于 printf(“%d\n”, 1 + 1);<br>打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="12-结构体变小写奇遇记"><a href="#12-结构体变小写奇遇记" class="headerlink" title="12. 结构体变小写奇遇记"></a>12. 结构体变小写奇遇记</h2><blockquote><p>计算出 Node 结构体的大小，并解释以下代码的运行结果。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="type">void</span> (*change)( <span class="keyword">struct</span> node *n);</span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; node-&gt;<span class="built_in">string</span>[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">        node-&gt;<span class="built_in">string</span>[i] = <span class="built_in">tolower</span>(node-&gt;<span class="built_in">string</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;WELCOME TO XIYOULINUX_GROUP!&quot;</span>;</span><br><span class="line">    Node *P = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node) + (<span class="built_in">strlen</span>(s) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(P-&gt;<span class="built_in">string</span>, s);</span><br><span class="line">    P-&gt;change = func;</span><br><span class="line">    P-&gt;change(P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, P-&gt;<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code> Node *P = (Node *)malloc(sizeof(Node) + (strlen(s) + 1) * sizeof(char));</code><br>malloc在堆区为Node和柔性数组开辟空间<br><code> strcpy(P-&gt;string, s);</code>将字符串s复制到柔性数组P-&gt;string中<br><code>P-&gt;change = func;</code>改变了函数指针change的指向，使其指向func()<br><code>P-&gt;change(P);</code>调用P-&gt;change指向的函数func(),在func()中用tolower将大写转换为小写<br>最后printf打印:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcome to xiyoulinux_group!</span><br></pre></td></tr></table></figure><h2 id="13-GNU-Linux-选做"><a href="#13-GNU-Linux-选做" class="headerlink" title="13. GNU&#x2F;Linux (选做)"></a>13. GNU&#x2F;Linux (选做)</h2><blockquote><p>注：嘿！你或许对Linux命令不是很熟悉，甚至没听说过Linux。<br>但别担心，这是选做题，了解Linux是加分项，不了解也不扣分哦！<br>你知道 ls 命令的用法与 &#x2F; . ~ 这些符号的含义吗？<br>你知道 Linux 中权限 rwx 的含义吗？<br>请问你还懂得哪些与 GNU&#x2F;Linux 相关的知识呢~</p></blockquote><blockquote><p>ls命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。<br>Linux系统中<code>/</code>表示 <strong>根目录</strong>  ；  <code>.</code>表示 <strong>当前目录</strong> ；<code>~</code>表示<strong>当前用户的目录</strong>。<br>例如 <code>ls /</code>会显示出根目录下的内容<br>rwx分别代表 Read Write eXecute (读取 写入 执行)权限。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;西邮Linux兴趣小组2024纳新题&quot;&gt;&lt;a href=&quot;#西邮Linux兴趣小组2024纳新题&quot; class=&quot;headerlink&quot; title=&quot;西邮Linux兴趣小组2024纳新题&quot;&gt;&lt;/a&gt;西邮Linux兴趣小组2024纳新题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="西邮Linux兴趣小组" scheme="http://aetherance.github.io/tags/%E8%A5%BF%E9%82%AELinux%E5%85%B4%E8%B6%A3%E5%B0%8F%E7%BB%84/"/>
    
  </entry>
  
</feed>
